[
  {
    "id": "section-1",
    "title": "ğŸ“š 1. PROGRAMAÃ‡ÃƒO ORIENTADA A OBJETOS (POO)",
    "questions": [
      {
        "id": "q-1-0",
        "title": "O que Ã© POO?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "POO Ã© um paradigma de programaÃ§Ã£o que organiza o cÃ³digo em torno de objetos, que sÃ£o instÃ¢ncias de classes. Esses objetos combinam dados (atributos) e comportamentos (mÃ©todos), permitindo modelar problemas do mundo real de forma mais intuitiva. \nNo meu dia a dia com Java, isso facilita muito a manutenÃ§Ã£o e reutilizaÃ§Ã£o de cÃ³digo. Por exemplo, ao modelar um sistema bancÃ¡rio, posso criar uma classe `Cliente` que encapsula CPF, nome e comportamentos como `validarIdade()`, refletindo exatamente como pensamos sobre clientes no mundo real.\nA POO contrasta com a programaÃ§Ã£o procedural, onde o cÃ³digo Ã© organizado em funÃ§Ãµes que manipulam dados. Com POO, os dados e as operaÃ§Ãµes sobre eles ficam juntos, aumentando a coesÃ£o e reduzindo o acoplamento."
      },
      {
        "id": "q-1-1",
        "title": "Quais sÃ£o os pilares da orientaÃ§Ã£o a objetos? Descreva sucintamente cada um deles.",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Os quatro pilares sÃ£o:\n**Encapsulamento:**\nProteger os dados internos de uma classe, expondo apenas o necessÃ¡rio atravÃ©s de mÃ©todos pÃºblicos. Uso bastante modificadores de acesso e getters/setters quando apropriado. Por exemplo, no meu projeto de crÃ©dito consignado, o CPF Ã© armazenado internamente como String limpa, mas exponho apenas mÃ©todos como `formatar()` e `mascarar()`. O estado interno fica protegido.\n**HeranÃ§a:**\nPermite que uma classe herde caracterÃ­sticas de outra, promovendo reuso de cÃ³digo. Sempre tento usar com cuidado para nÃ£o criar hierarquias muito complexas - prefiro composiÃ§Ã£o sobre heranÃ§a na maioria dos casos. Um bom uso Ã© quando realmente existe uma relaÃ§Ã£o \"Ã© um\", como `ContaCorrente extends Conta`.\n**Polimorfismo:**\nCapacidade de objetos de classes diferentes responderem Ã  mesma mensagem de formas distintas. Utilizo muito com interfaces e sobrescrita de mÃ©todos. Por exemplo, tenho uma interface `ClienteRepository` que pode ter implementaÃ§Ãµes diferentes (`ClienteJpaRepository`, `ClienteInMemoryRepository`) - o cÃ³digo cliente nÃ£o precisa saber qual estÃ¡ sendo usada.\n**AbstraÃ§Ã£o:**\nFocar no essencial, ocultando detalhes complexos. Classes abstratas e interfaces sÃ£o ferramentas que uso frequentemente para isso. No meu projeto, `CadastrarClienteUseCase` Ã© uma interface que abstrai completamente como o cadastro Ã© feito - o Controller sÃ³ sabe que pode chamar `executar()`.",
        "code": "public record CPF(String valor) {\n    // valor Ã© privado implicitamente\n    public String formatar() { return \"XXX.XXX.XXX-XX\"; }\n    public String mascarar() { return \"***.***.***-XX\"; }\n}",
        "tip": "Focar no essencial, ocultando detalhes complexos. Classes abstratas e interfaces sÃ£o ferramentas que uso frequentemente para isso. No meu projeto, `CadastrarClienteUseCase` Ã© uma interface que abstrai completamente como o cadastro Ã© feito - o Controller sÃ³ sabe que pode chamar `executar()`."
      },
      {
        "id": "q-1-2",
        "title": "Qual a diferenÃ§a entre classe abstrata e interface?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Essa Ã© uma pergunta clÃ¡ssica que mostra entendimento profundo de OOP:\n**Classe Abstrata:**\n- Pode ter implementaÃ§Ã£o de mÃ©todos (concretos e abstratos)\n- Pode ter estado (atributos de instÃ¢ncia)\n- Pode ter construtores\n- HeranÃ§a Ãºnica: uma classe sÃ³ pode estender uma classe abstrata\n- Uso quando tenho cÃ³digo comum que quero compartilhar entre subclasses\n**Interface:**\n- Antes do Java 8: apenas mÃ©todos abstratos\n- Java 8+: pode ter mÃ©todos default e static\n- Apenas constantes (public static final)\n- NÃ£o tem construtores\n- MÃºltipla implementaÃ§Ã£o: uma classe pode implementar vÃ¡rias interfaces\n- Uso para definir contratos\n**Quando usar cada:**\n- **Interface:** Quando quero definir um contrato que mÃºltiplas classes nÃ£o relacionadas podem implementar (ex: `Serializable`, `Comparable`)\n- **Classe Abstrata:** Quando tenho cÃ³digo comum que quero compartilhar E as classes tÃªm uma relaÃ§Ã£o hierÃ¡rquica clara (ex: `Conta -> ContaCorrente, ContaPoupanca`)\n**Regra prÃ¡tica:** Prefira interfaces. Use classe abstrata apenas quando realmente precisa compartilhar cÃ³digo.",
        "code": "public interface Pagavel {\n    void pagar(BigDecimal valor);\n    \n    default boolean podePagar(BigDecimal valor) {\n        return true; // ImplementaÃ§Ã£o default\n    }\n}"
      }
    ]
  },
  {
    "id": "section-2",
    "title": "ğŸ—ï¸ 2. PRINCÃPIOS E PADRÃ•ES DE DESIGN",
    "questions": [
      {
        "id": "q-2-0",
        "title": "Fale sobre os princÃ­pios SOLID.",
        "tags": [
          "importante"
        ],
        "content": "SOLID Ã© um conjunto de princÃ­pios que me guiam para escrever cÃ³digo mais limpo e manutenÃ­vel. Aprendi que aplicar SOLID nÃ£o Ã© sobre seguir regras cegamente, mas entender o \"porquÃª\" de cada princÃ­pio:\n**S - Single Responsibility Principle (Responsabilidade Ãšnica):**\nCada classe deve ter apenas uma responsabilidade, apenas um motivo para mudar. Evito criar \"classes Deus\" que fazem tudo. \nNo meu projeto, separei `ClienteService` (orquestraÃ§Ã£o) de `ClienteRepository` (persistÃªncia) de `ClienteController` (HTTP). Cada um muda por motivos diferentes: regras de negÃ³cio, banco de dados, ou API.\n**O - Open/Closed Principle (Aberto/Fechado):**\nClasses devem estar abertas para extensÃ£o, mas fechadas para modificaÃ§Ã£o. Uso muito interfaces e heranÃ§a para isso. \nExemplo: Se amanhÃ£ precisar de um novo tipo de cÃ¡lculo de IOF, nÃ£o modifico a classe existente - crio uma nova implementaÃ§Ã£o da interface `CalculadoraIOF`.\n**L - Liskov Substitution Principle (SubstituiÃ§Ã£o de Liskov):**\nSubclasses devem poder substituir suas superclasses sem quebrar o sistema. \nTeste mental: se tenho um mÃ©todo que recebe `Conta`, posso passar `ContaCorrente` ou `ContaPoupanca` e tudo continua funcionando? Se nÃ£o, violei Liskov.\n**I - Interface Segregation Principle (SegregaÃ§Ã£o de Interfaces):**\nPrefiro interfaces menores e especÃ­ficas a uma interface grande e genÃ©rica. Isso evita que classes implementem mÃ©todos que nÃ£o precisam.\n**D - Dependency Inversion Principle (InversÃ£o de DependÃªncia):**\nDependo de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes concretas. Isso casa perfeitamente com injeÃ§Ã£o de dependÃªncias no Spring.",
        "tip": "No meu projeto, separei `ClienteService` (orquestraÃ§Ã£o) de `ClienteRepository` (persistÃªncia) de `ClienteController` (HTTP). Cada um muda por motivos diferentes: regras de negÃ³cio, banco de dados, ou API.",
        "code": "// Ruim: depende de implementaÃ§Ã£o\npublic class ClienteService {\n    private ClienteJpaRepository repository = new ClienteJpaRepository();\n}\n\n// Bom: depende de abstraÃ§Ã£o\npublic class ClienteService {\n    private final ClienteRepository repository; // Interface\n    \n    public ClienteService(ClienteRepository repository) {\n        this.repository = repository;\n    }\n}"
      },
      {
        "id": "q-2-1",
        "title": "O que Ã© Clean Code? Como vocÃª aplica no dia a dia?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Clean Code sÃ£o prÃ¡ticas para escrever cÃ³digo legÃ­vel e manutenÃ­vel, popularizadas pelo livro do Uncle Bob (Robert C. Martin). A ideia central Ã© que cÃ³digo Ã© lido muito mais vezes do que escrito, entÃ£o devemos otimizar para leitura.\n**PrincÃ­pios que aplico diariamente:**\n**1. Nomes Significativos:**\n**2. FunÃ§Ãµes Pequenas:**\nCada funÃ§Ã£o deve fazer uma coisa sÃ³, e fazer bem. Se preciso de um comentÃ¡rio explicando o que um bloco faz, deveria ser uma funÃ§Ã£o separada.\n**3. Sem ComentÃ¡rios DesnecessÃ¡rios:**\nCÃ³digo auto-explicativo nÃ£o precisa de comentÃ¡rios. ComentÃ¡rios mentem quando o cÃ³digo muda e ninguÃ©m atualiza o comentÃ¡rio.\n**4. DRY (Don't Repeat Yourself):**\nSe vejo cÃ³digo duplicado, extraio para um mÃ©todo ou classe.\n**5. Tratamento de Erros:**\nPrefiro exceptions a cÃ³digos de erro. E trato exceptions no nÃ­vel apropriado (GlobalExceptionHandler no meu projeto).\n**6. Testes:**\nCÃ³digo limpo tem testes. Se nÃ£o consigo testar facilmente, provavelmente o cÃ³digo nÃ£o estÃ¡ limpo.",
        "code": "// Ruim: comentÃ¡rio Ã³bvio\n// Incrementa contador\ncontador++;\n\n// Bom: cÃ³digo que se explica\nint numeroDeTentativas = 0;\nnumeroDeTentativas++;"
      },
      {
        "id": "q-2-2",
        "title": "O que Ã© Clean Architecture?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Clean Architecture Ã© uma arquitetura proposta por Uncle Bob que organiza o cÃ³digo em camadas concÃªntricas, com a regra de que dependÃªncias sempre apontam para dentro.\n**Regra da DependÃªncia:**\nO cÃ³digo nas camadas internas nÃ£o pode saber NADA sobre as camadas externas. Isso significa que:\n- Entities nÃ£o conhecem Use Cases\n- Use Cases nÃ£o conhecem Controllers\n- Nada no core conhece Spring ou JPA\n**BenefÃ­cios que vejo na prÃ¡tica:**\n1. **Testabilidade:** Posso testar regras de negÃ³cio sem banco, sem web server\n2. **IndependÃªncia de frameworks:** Posso trocar Spring por Quarkus sem tocar no domÃ­nio\n3. **IndependÃªncia de UI:** Web, mobile, CLI - mesmo core\n4. **IndependÃªncia de banco:** PostgreSQL, MongoDB - mesmo core\n**No meu projeto ConsignadoHub:**\n- **Entities:** `Cliente`, `Beneficio`, VOs como `CPF`, `Dinheiro`\n- **Use Cases:** `CadastrarClienteUseCase`, `BuscarClienteQuery`\n- **Interface Adapters:** `ClienteController`, `ClienteRepositoryAdapter`\n- **Frameworks:** Spring Boot, JPA, PostgreSQL",
        "code": "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              FRAMEWORKS & DRIVERS (mais externo)         â”‚\nâ”‚  Spring, Hibernate, Controllers, Banco de Dados         â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚   â”‚           INTERFACE ADAPTERS                     â”‚   â”‚\nâ”‚   â”‚   Presenters, Gateways, Controllers              â”‚   â”‚\nâ”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚\nâ”‚   â”‚   â”‚        APPLICATION BUSINESS RULES        â”‚   â”‚   â”‚\nâ”‚   â”‚   â”‚   Use Cases (orquestraÃ§Ã£o)               â”‚   â”‚   â”‚\nâ”‚   â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚   â”‚\nâ”‚   â”‚   â”‚   â”‚   ENTERPRISE BUSINESS RULES     â”‚   â”‚   â”‚   â”‚\nâ”‚   â”‚   â”‚   â”‚   Entities (regras de negÃ³cio)  â”‚   â”‚   â”‚   â”‚\nâ”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚   â”‚\nâ”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜",
        "tip": "No meu projeto ConsignadoHub:"
      },
      {
        "id": "q-2-3",
        "title": "Quais Design Patterns vocÃª mais usa? DÃª exemplos prÃ¡ticos.",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Uso diversos patterns, mas alguns sÃ£o realmente frequentes no meu dia a dia:\n**Factory Method:**\nPara criaÃ§Ã£o de objetos complexos ou quando quero esconder a lÃ³gica de criaÃ§Ã£o.\n**Strategy:**\nPara mÃºltiplos algoritmos intercambiÃ¡veis. Muito Ãºtil quando tenho if/else ou switch que cresce.\n**Repository:**\nAbstrai a camada de persistÃªncia. O domÃ­nio nÃ£o sabe se estou usando JPA, MongoDB ou arquivo.\n**Builder:**\nPara construÃ§Ã£o de objetos complexos passo a passo. Lombok gera automaticamente.\n**Adapter:**\nConverte uma interface em outra. Uso muito para integrar camadas.\n**Singleton:**\nUma Ãºnica instÃ¢ncia. No Spring, todos os beans sÃ£o singleton por padrÃ£o - nÃ£o preciso implementar manualmente.",
        "code": "// Adapter que implementa Port do domÃ­nio usando JPA\n@Repository\npublic class ClienteRepositoryAdapter implements ClienteRepository {\n    private final ClienteJpaRepository jpaRepository;\n    private final ClienteMapper mapper;\n    \n    @Override\n    public Cliente salvar(Cliente cliente) {\n        ClienteJpaEntity entity = mapper.toEntity(cliente);\n        jpaRepository.save(entity);\n        return cliente;\n    }\n}"
      },
      {
        "id": "q-2-4",
        "title": "Como os princÃ­pios SOLID se combinam com Clean Architecture?",
        "tags": [
          "intermediÃ¡rio",
          "importante"
        ],
        "content": "Clean Architecture e SOLID sÃ£o complementares. A Clean Architecture organiza o cÃ³digo em camadas concÃªntricas com a regra de que dependÃªncias apontam para dentro. Isso Ã© exatamente o princÃ­pio D do SOLID (InversÃ£o de DependÃªncia) aplicado em nÃ­vel arquitetural.",
        "table": {
          "headers": [
            "PrincÃ­pio SOLID",
            "Como Aplica na Clean Architecture"
          ],
          "rows": [
            [
              "**S - Single Responsibility**",
              "Cada camada tem uma responsabilidade: Domain (regras), Application (orquestraÃ§Ã£o), Adapters (conversÃ£o)"
            ],
            [
              "**O - Open/Closed**",
              "Adiciono novos Use Cases sem modificar os existentes. Novos Adapters sem tocar no Domain"
            ],
            [
              "**L - Liskov Substitution**",
              "Posso trocar `ClienteJpaRepository` por `ClienteInMemoryRepository` - ambos implementam `ClienteRepository`"
            ],
            [
              "**I - Interface Segregation**",
              "Separo `CadastrarClienteUseCase` de `BuscarClienteQuery` - interfaces pequenas e focadas"
            ],
            [
              "**D - Dependency Inversion**",
              "O Domain define interfaces (Ports), Adapters implementam. DependÃªncia sempre aponta para dentro"
            ]
          ]
        },
        "answer": "Clean Architecture Ã© a ESTRUTURA, SOLID sÃ£o as REGRAS de como construir cada parte. O princÃ­pio D (InversÃ£o de DependÃªncia) Ã© o coraÃ§Ã£o da Clean Architecture - o Domain define interfaces como `ClienteRepository`, e a camada de Adapters implementa com `ClienteJpaRepository`. O Domain nÃ£o conhece JPA, depende de abstraÃ§Ãµes. Resumindo: SOLID sÃ£o os princÃ­pios para escrever classes boas, Clean Architecture Ã© como organizar essas classes respeitando esses princÃ­pios."
      },
      {
        "id": "q-2-5",
        "title": "O que sÃ£o Use Cases?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Use Cases sÃ£o as AÃ‡Ã•ES que o sistema sabe fazer. Cada Use Case representa uma operaÃ§Ã£o de negÃ³cio que um usuÃ¡rio pode executar.\n**Estrutura de um Use Case:**\n**Use Case vs Service Tradicional:**",
        "code": "// Interface (Port de entrada)\npublic interface CadastrarClienteUseCase {\n    ClienteId executar(CadastrarClienteCommand command);\n}\n\n// ImplementaÃ§Ã£o (Service)\n@Service\npublic class CadastrarClienteService implements CadastrarClienteUseCase {\n    \n    private final ClienteRepository repository;  // Port de saÃ­da\n    \n    @Override\n    public ClienteId executar(CadastrarClienteCommand command) {\n        // 1. Criar entidade de domÃ­nio\n        Cliente cliente = Cliente.criar(new CPF(command.cpf()), command.nome());\n        \n        // 2. Aplicar regras de negÃ³cio\n        if (repository.existePorCpf(cliente.getCpf())) {\n            throw BusinessException.cpfJaCadastrado(cliente.getCpf());\n        }\n        \n        // 3. Persistir\n        return repository.salvar(cliente);\n    }\n}",
        "table": {
          "headers": [
            "Service Tradicional",
            "Use Case (Clean Architecture)"
          ],
          "rows": [
            [
              "Classe com vÃ¡rios mÃ©todos",
              "Uma interface = Uma aÃ§Ã£o"
            ],
            [
              "`ClienteService.cadastrar()`, `.buscar()`",
              "`CadastrarClienteUseCase`, `BuscarClienteQuery`"
            ],
            [
              "Tende a virar \"God Class\"",
              "Cada use case Ã© pequeno e focado"
            ],
            [
              "DifÃ­cil de testar isoladamente",
              "FÃ¡cil de mockar dependÃªncias"
            ]
          ]
        },
        "answer": "Use Cases representam as aÃ§Ãµes de negÃ³cio que o sistema oferece. Cada Use Case Ã© uma interface com um Ãºnico mÃ©todo - geralmente `executar()`. Isso segue o Single Responsibility: uma classe, uma razÃ£o para mudar. A vantagem Ã© que o Controller sÃ³ conhece a interface `CadastrarClienteUseCase`, nÃ£o a implementaÃ§Ã£o. Posso trocar a implementaÃ§Ã£o sem tocar no Controller."
      }
    ]
  },
  {
    "id": "section-3",
    "title": "ğŸ›ï¸ 3. ARQUITETURA E METODOLOGIAS",
    "questions": [
      {
        "id": "q-3-0",
        "title": "Explique a metodologia DDD de acordo com o seu entendimento.",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "DDD (Domain-Driven Design) Ã© uma abordagem que coloca o domÃ­nio do negÃ³cio no centro do desenvolvimento. Foi proposta por Eric Evans e mudou como penso sobre arquitetura de software.\n**Conceitos EstratÃ©gicos:**\n**Linguagem UbÃ­qua:**\nDesenvolvedores e especialistas de negÃ³cio usam os mesmos termos. Se o negÃ³cio fala \"margem consignÃ¡vel\", meu cÃ³digo tem `margemConsignavel`, nÃ£o `availableMargin` ou `margem_disponivel`.\n**Bounded Contexts:**\nDivisÃ£o do sistema em contextos com fronteiras claras. Cada contexto tem seu prÃ³prio modelo. \"Cliente\" no contexto de Cadastro Ã© diferente de \"Cliente\" no contexto de CobranÃ§a.\n**Conceitos TÃ¡ticos:**\n**Entities:**\nObjetos com identidade Ãºnica. Dois clientes com mesmo nome sÃ£o diferentes se tÃªm IDs diferentes.\n**Value Objects:**\nImutÃ¡veis, sem identidade. Dois CPFs com mesmo valor sÃ£o iguais.\n**Aggregates:**\nCluster de entidades tratadas como unidade. Aggregate Root Ã© o Ãºnico ponto de entrada.\n**Repositories:**\nInterface para persistÃªncia, definida no domÃ­nio, implementada na infraestrutura.\n**Domain Services:**\nQuando uma operaÃ§Ã£o nÃ£o pertence naturalmente a nenhuma entidade.\n**No meu projeto ConsignadoHub:**\nAplico DDD dividindo claramente: VOs (CPF, Dinheiro), Entities (Cliente, Beneficio), Aggregates (Cliente como root), e Repositories (ClienteRepository).",
        "code": "public class Cliente { // Aggregate Root\n    private List<Beneficio> beneficios; // Parte do agregado\n    \n    public void adicionarBeneficio(Beneficio beneficio) {\n        // Regras de negÃ³cio aqui\n        this.beneficios.add(beneficio);\n    }\n}\n// Nunca acesso Beneficio diretamente, sempre via Cliente",
        "tip": "No meu projeto ConsignadoHub:"
      },
      {
        "id": "q-3-1",
        "title": "Como funciona a arquitetura de microserviÃ§os?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Ã‰ uma abordagem onde dividimos a aplicaÃ§Ã£o em serviÃ§os menores, independentes e especializados. Cada microserviÃ§o:\n**CaracterÃ­sticas:**\n- **Tem seu prÃ³prio banco de dados:** NÃ£o compartilha dados diretamente com outros serviÃ§os\n- **Deploy independente:** Posso atualizar um sem afetar outros\n- **Tecnologia independente:** Cada um pode usar linguagem/framework diferentes\n- **Time autÃ´nomo:** Um time cuida do serviÃ§o end-to-end\n**ComunicaÃ§Ã£o:**\n- **SÃ­ncrona:** REST, gRPC (quando precisa de resposta imediata)\n- **AssÃ­ncrona:** Mensageria como Kafka, RabbitMQ (para desacoplamento)\n**PadrÃµes importantes:**\n- **API Gateway:** Ponto de entrada Ãºnico\n- **Service Discovery:** ServiÃ§os se encontram dinamicamente\n- **Circuit Breaker:** Evita cascata de falhas\n- **Saga:** TransaÃ§Ãµes distribuÃ­das\n**Trade-offs que considero:**\n**Quando usar:**\n- Times grandes que precisam de autonomia\n- Partes do sistema com escalas diferentes\n- Quando jÃ¡ entende bem o domÃ­nio (nÃ£o para MVP)\n**Quando NÃƒO usar:**\n- MVP, prova de conceito\n- Times pequenos (<10 pessoas)\n- Quando nÃ£o tem observabilidade madura",
        "table": {
          "headers": [
            "BenefÃ­cios",
            "Desafios"
          ],
          "rows": [
            [
              "Escala independente",
              "Complexidade operacional"
            ],
            [
              "Times autÃ´nomos",
              "TransaÃ§Ãµes distribuÃ­das"
            ],
            [
              "Deploy independente",
              "LatÃªncia de rede"
            ],
            [
              "Falha isolada",
              "ConsistÃªncia eventual"
            ],
            [
              "Tecnologia heterogÃªnea",
              "Monitoramento distribuÃ­do"
            ]
          ]
        }
      },
      {
        "id": "q-3-2",
        "title": "O que Ã© arquitetura Hexagonal?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "TambÃ©m conhecida como Ports and Adapters, Ã© um padrÃ£o arquitetural criado por Alistair Cockburn que isola a lÃ³gica de negÃ³cio das dependÃªncias externas.\n**Estrutura:**\n**Conceitos chave:**\n**Ports (Portas):**\nInterfaces que definem como o mundo externo interage com a aplicaÃ§Ã£o.\n- **Ports de Entrada (Driving):** Use Cases, como `CadastrarClienteUseCase`\n- **Ports de SaÃ­da (Driven):** RepositÃ³rios, como `ClienteRepository`\n**Adapters (Adaptadores):**\nImplementaÃ§Ãµes concretas das ports.\n- **Adapters de Entrada:** `ClienteController` (HTTP â†’ Use Case)\n- **Adapters de SaÃ­da:** `ClienteRepositoryAdapter` (Use Case â†’ JPA)\n**BenefÃ­cios que experimento:**\n1. **Testabilidade:** Testo domÃ­nio sem banco, sem web\n2. **IndependÃªncia de frameworks:** DomÃ­nio nÃ£o conhece Spring\n3. **Troca fÃ¡cil de tecnologias:** Posso trocar PostgreSQL por MongoDB trocando sÃ³ o adapter\n4. **CÃ³digo organizado:** Cada coisa no seu lugar\n**No meu ConsignadoHub:**",
        "code": "adapter/in/web/          â†’ Controllers (HTTP)\nadapter/out/persistence/ â†’ JPA (Banco)\napplication/port/in/     â†’ Use Cases (interfaces)\napplication/port/out/    â†’ Repositories (interfaces)\napplication/service/     â†’ ImplementaÃ§Ãµes dos Use Cases\ndomain/model/            â†’ Entidades\ndomain/vo/               â†’ Value Objects\ndomain/exception/        â†’ ExceÃ§Ãµes de domÃ­nio"
      },
      {
        "id": "q-3-3",
        "title": "E outras arquiteturas? Pode citar algumas?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "AlÃ©m de Hexagonal, existem vÃ¡rias arquiteturas que uso ou conheÃ§o:\n**MonolÃ­tica:**\nTudo em uma aplicaÃ§Ã£o. Simples para comeÃ§ar, difÃ­cil de escalar partes independentemente.\n- **Quando usar:** MVP, times pequenos, prova de conceito\n- **Quando evitar:** Quando partes diferentes tÃªm escalas muito diferentes\n**MicroserviÃ§os:**\nServiÃ§os pequenos, independentes, com seu prÃ³prio banco.\n- **Quando usar:** Times grandes, escala independente necessÃ¡ria\n- **Quando evitar:** MVP, times pequenos, sem observabilidade madura\n**Event-Driven:**\nComunicaÃ§Ã£o baseada em eventos. ServiÃ§os publicam/consomem eventos.\n- **Quando usar:** Desacoplamento forte, eventual consistency OK\n- **Quando evitar:** Quando precisa de consistÃªncia imediata\n**Serverless:**\nFunÃ§Ãµes executadas sob demanda (AWS Lambda, Azure Functions).\n- **Quando usar:** Workloads variÃ¡veis, eventos esporÃ¡dicos\n- **Quando evitar:** Processamento contÃ­nuo, cold start Ã© problema\n**CQRS (Command Query Responsibility Segregation):**\nModelos separados para leitura e escrita, potencialmente bancos diferentes.\n- **Quando usar:** Alto volume de leitura, Event Sourcing\n- **Quando evitar:** CRUD simples, complexidade desnecessÃ¡ria\n**Layered (Camadas):**\nTradicional: Presentation â†’ Business â†’ Data Access.\n- **Quando usar:** AplicaÃ§Ãµes simples, equipe acostumada\n- **Quando evitar:** Quando quer isolar domÃ­nio de frameworks"
      },
      {
        "id": "q-3-4",
        "title": "O que Ã© Saga Pattern?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Saga Ã© um padrÃ£o para gerenciar transaÃ§Ãµes distribuÃ­das em arquiteturas de microserviÃ§os, onde nÃ£o podemos usar transaÃ§Ãµes ACID tradicionais.\n**O problema:**\nEm um monolito, posso fazer:\nEm microserviÃ§os, cada operaÃ§Ã£o estÃ¡ em um serviÃ§o diferente com seu banco. Preciso de Saga.\n**Como funciona:**\nUma Saga Ã© uma sequÃªncia de transaÃ§Ãµes locais. Cada serviÃ§o:\n1. Executa sua transaÃ§Ã£o local\n2. Publica um evento\n3. PrÃ³ximo serviÃ§o reage ao evento\nSe alguma etapa falhar, executa **compensaÃ§Ãµes** (rollback semÃ¢ntico):\n**Tipos de Saga:**\n**Choreography (Coreografado):**\nCada serviÃ§o sabe o que fazer quando recebe um evento. Descentralizado.\n- **Vantagem:** Simples, desacoplado\n- **Desvantagem:** Fluxo difÃ­cil de visualizar\n**Orchestration (Orquestrado):**\nUm orquestrador central controla o fluxo.\n- **Vantagem:** Fluxo claro, centralizado\n- **Desvantagem:** Orquestrador Ã© ponto Ãºnico de falha\n**No contexto de crÃ©dito consignado:**\n1. **ContratoService:** Cria contrato (compensaÃ§Ã£o: marcar como cancelado)\n2. **INSSService:** Averba no INSS (compensaÃ§Ã£o: desaverbar)\n3. **PagamentoService:** Libera dinheiro (compensaÃ§Ã£o: solicitar estorno)",
        "code": "Orquestrador --> ContratoService\n            --> AverbacaoService  \n            --> LiberacaoService"
      },
      {
        "id": "q-3-5",
        "title": "Qual a diferenÃ§a entre CQS e CQRS?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Essa distinÃ§Ã£o Ã© importante e muita gente confunde:\n**CQS (Command Query Separation):**\nPrincÃ­pio de design onde mÃ©todos sÃ£o ou Commands (alteram estado) ou Queries (leem estado), nunca ambos.\nNo meu projeto, aplico separando interfaces:\n**Mesmo banco, interfaces separadas.** Complexidade baixa.\n**CQRS (Command Query Responsibility Segregation):**\nArquitetura onde temos modelos diferentes para leitura e escrita, potencialmente bancos diferentes.\n**Bancos diferentes, modelos diferentes.** Complexidade alta.\n**Quando usar cada:**",
        "code": "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Commands   â”‚         â”‚   Queries    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n       â”‚                        â”‚\n       â–¼                        â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Write Model  â”‚  â”€â”€â”€â”€â”€â–º â”‚ Read Model   â”‚\nâ”‚  (DynamoDB)  â”‚ eventos â”‚ (PostgreSQL) â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜",
        "tip": "No meu projeto, aplico separando interfaces:",
        "table": {
          "headers": [
            "SituaÃ§Ã£o",
            "PadrÃ£o"
          ],
          "rows": [
            [
              "CRUD simples",
              "Nem CQS (normal)"
            ],
            [
              "Separar leitura/escrita logicamente",
              "CQS"
            ],
            [
              "Alto volume de leitura vs escrita",
              "CQRS"
            ],
            [
              "Event Sourcing",
              "CQRS (obrigatÃ³rio)"
            ]
          ]
        }
      }
    ]
  },
  {
    "id": "section-4",
    "title": "ğŸ’¾ 4. BANCO DE DADOS",
    "questions": [
      {
        "id": "q-4-0",
        "title": "Qual a diferenÃ§a entre banco de dados relacional e nÃ£o-relacional e quando utilizar cada um?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "Esta Ã© uma pergunta fundamental para arquitetura:\n**Bancos Relacionais (SQL):**\nOrganizam dados em tabelas com linhas e colunas, relacionadas por chaves.\nCaracterÃ­sticas:\n- Schema fixo e estruturado\n- Garantias ACID\n- SQL para queries complexas\n- Joins eficientes\n- Integridade referencial\nExemplos: PostgreSQL, MySQL, Oracle, SQL Server\n**Quando usar:**\n- Dados altamente estruturados\n- TransaÃ§Ãµes financeiras (ACID Ã© crÃ­tico)\n- RelatÃ³rios complexos com muitos joins\n- Relacionamentos complexos entre entidades\n- Quando consistÃªncia imediata Ã© necessÃ¡ria\n**Bancos NÃ£o-Relacionais (NoSQL):**\nVÃ¡rias categorias com modelos diferentes:\nCaracterÃ­sticas:\n- Schema flexÃ­vel\n- Eventual consistency (geralmente)\n- Escala horizontal mais fÃ¡cil\n- Otimizado para padrÃµes especÃ­ficos de acesso\n**Quando usar:**\n- Dados semi ou nÃ£o estruturados (logs, documentos)\n- Alta escala de escrita\n- Esquema que muda frequentemente\n- Quando eventual consistency Ã© aceitÃ¡vel\n- Cache de alta performance\n**No meu projeto ConsignadoHub:**\nUso PostgreSQL (relacional) porque:\n- Dados de clientes sÃ£o estruturados\n- Preciso de ACID para transaÃ§Ãµes financeiras\n- RelatÃ³rios com joins sÃ£o importantes\nPara Event Sourcing (futuro), usaria DynamoDB (NoSQL) pelo alto throughput de escrita.",
        "table": {
          "headers": [
            "Tipo",
            "Exemplos",
            "Uso"
          ],
          "rows": [
            [
              "Documentos",
              "MongoDB, Couchbase",
              "Dados semi-estruturados"
            ],
            [
              "Chave-Valor",
              "Redis, DynamoDB",
              "Cache, sessÃµes"
            ],
            [
              "Colunar",
              "Cassandra, HBase",
              "Analytics, sÃ©ries temporais"
            ],
            [
              "Grafos",
              "Neo4j",
              "Relacionamentos complexos"
            ]
          ]
        },
        "tip": "No meu projeto ConsignadoHub:"
      },
      {
        "id": "q-4-1",
        "title": "Explique transaÃ§Ãµes ACID.",
        "tags": [
          "bÃ¡sico",
          "importante"
        ],
        "content": "ACID Ã© um acrÃ´nimo que define as propriedades que garantem confiabilidade em transaÃ§Ãµes de banco de dados:\n**A - Atomicidade (Atomicity):**\nTudo ou nada. Uma transaÃ§Ã£o Ã© indivisÃ­vel. Se qualquer parte falha, toda a transaÃ§Ã£o Ã© revertida.\nExemplo prÃ¡tico:\n**C - ConsistÃªncia (Consistency):**\nA transaÃ§Ã£o leva o banco de um estado vÃ¡lido para outro estado vÃ¡lido. Todas as regras de integridade sÃ£o respeitadas.\nExemplo: Se tenho uma constraint de saldo >= 0, a transaÃ§Ã£o que deixaria saldo negativo falha.\n**I - Isolamento (Isolation):**\nTransaÃ§Ãµes concorrentes nÃ£o interferem umas nas outras. Ã‰ como se cada uma executasse sozinha.\nNÃ­veis de isolamento (do mais permissivo ao mais restritivo):\n- READ UNCOMMITTED: VÃª dados nÃ£o commitados (sujeira)\n- READ COMMITTED: SÃ³ vÃª dados commitados\n- REPEATABLE READ: Leituras consistentes na mesma transaÃ§Ã£o\n- SERIALIZABLE: Como se executasse em sÃ©rie\n**D - Durabilidade (Durability):**\nUma vez que a transaÃ§Ã£o Ã© commitada, ela persiste mesmo em caso de falha do sistema (queda de energia, crash).\n**No Spring:**",
        "code": "@Transactional\npublic void transferir(Conta origem, Conta destino, BigDecimal valor) {\n    origem.debitar(valor);  // Se isso OK mas...\n    destino.creditar(valor); // ...isso falhar, origem Ã© revertido\n}"
      },
      {
        "id": "q-4-2",
        "title": "O que Ã© o problema N+1 e como resolver?",
        "tags": [
          "bÃ¡sico",
          "importante"
        ],
        "content": "O problema N+1 Ã© um dos bugs de performance mais comuns em aplicaÃ§Ãµes com ORM (JPA/Hibernate).\n**O problema:**\nQuando tenho uma relaÃ§Ã£o lazy e acesso os itens relacionados em um loop:\nSe tenho 100 pedidos: 1 query inicial + 100 queries para buscar cada cliente = 101 queries!\n**SoluÃ§Ãµes:**\n**1. JOIN FETCH (JPQL):**\n**2. @EntityGraph:**\n**3. @BatchSize:**\n**4. Projections/DTOs:**\n**Como detectar:**\n- Logs de SQL com `show-sql: true`\n- Ferramentas como P6Spy\n- APM (Application Performance Monitoring)",
        "code": "@Query(\"SELECT new com.app.dto.PedidoResumo(p.id, c.nome) FROM Pedido p JOIN p.cliente c\")\nList<PedidoResumo> findResumos();"
      }
    ]
  },
  {
    "id": "section-5",
    "title": "ğŸ“¬ 5. MENSAGERIA",
    "questions": [
      {
        "id": "q-5-0",
        "title": "Como funciona um sistema de mensageria?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Um sistema de mensageria permite comunicaÃ§Ã£o assÃ­ncrona entre aplicaÃ§Ãµes atravÃ©s de filas ou tÃ³picos. Ã‰ fundamental em arquiteturas distribuÃ­das.\n**Funcionamento bÃ¡sico:**\n1. **Produtor** envia mensagem para o broker\n2. **Broker** armazena a mensagem (persistÃªncia opcional)\n3. **Consumidor** busca/recebe mensagens no seu ritmo\n4. **Acknowledgment** confirma processamento\n**Vantagens:**\n**Exemplo prÃ¡tico no consignado:**\nSem mensageria, o ContratoService teria que chamar cada um desses serviÃ§os sincronamente, acoplando tudo.",
        "code": "ContratoService publica \"ContratoAssinado\"\n    â”‚\n    â”œâ”€â”€â–º NotificacaoService: Envia email\n    â”œâ”€â”€â–º AverbacaoService: Inicia processo no INSS\n    â””â”€â”€â–º AuditoriaService: Registra log",
        "table": {
          "headers": [
            "BenefÃ­cio",
            "DescriÃ§Ã£o"
          ],
          "rows": [
            [
              "Desacoplamento",
              "Produtor nÃ£o conhece consumidor"
            ],
            [
              "ResiliÃªncia",
              "Mensagens sobrevivem a falhas"
            ],
            [
              "Escalabilidade",
              "Adicionar consumidores sob demanda"
            ],
            [
              "Buffer",
              "Absorve picos de carga"
            ],
            [
              "AssÃ­ncrono",
              "NÃ£o bloqueia o produtor"
            ]
          ]
        }
      },
      {
        "id": "q-5-1",
        "title": "Qual a diferenÃ§a entre RabbitMQ e Kafka?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "SÃ£o ferramentas diferentes para problemas diferentes:\n**RabbitMQ:**\n- Message Broker tradicional baseado em AMQP\n- Modelo: fila de mensagens\n- Mensagens sÃ£o removidas apÃ³s consumo\n- Roteamento flexÃ­vel com exchanges\n- Garantia de entrega por mensagem\n**Ideal para:**\n- ComunicaÃ§Ã£o entre microsserviÃ§os\n- Filas de trabalho (work queues)\n- RPC assÃ­ncrono\n- Quando precisa de roteamento complexo\n**Kafka:**\n- Plataforma de streaming distribuÃ­do\n- Modelo: log append-only\n- Mensagens mantidas por perÃ­odo configurÃ¡vel (retention)\n- MÃºltiplos consumidores podem ler mesma mensagem\n- Otimizado para throughput massivo\n**Ideal para:**\n- Event sourcing\n- Logs e mÃ©tricas\n- Processamento de streams em tempo real\n- Quando precisa de replay de eventos\n- Alta escala (milhÃµes de mensagens/segundo)\n**ComparaÃ§Ã£o:**\n**Minha escolha:**\n- ComunicaÃ§Ã£o microserviÃ§os simples â†’ RabbitMQ\n- Event Sourcing, analytics, alta escala â†’ Kafka",
        "table": {
          "headers": [
            "Aspecto",
            "RabbitMQ",
            "Kafka"
          ],
          "rows": [
            [
              "Modelo",
              "Message Queue",
              "Event Log"
            ],
            [
              "Retention",
              "AtÃ© consumir",
              "ConfigurÃ¡vel (dias/semanas)"
            ],
            [
              "Throughput",
              "Alto",
              "Muito alto"
            ],
            [
              "Replay",
              "NÃ£o (padrÃ£o)",
              "Sim"
            ],
            [
              "Complexidade",
              "Menor",
              "Maior"
            ],
            [
              "Caso de uso",
              "Mensageria",
              "Streaming"
            ]
          ]
        }
      },
      {
        "id": "q-5-2",
        "title": "Explique os conceitos de fila e tÃ³pico em mensageria.",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "**Fila (Queue) - Modelo Ponto-a-Ponto:**\nCada mensagem Ã© consumida por apenas um consumidor, mesmo que existam vÃ¡rios consumidores escutando.\nÃštil para: Distribuir trabalho entre workers. Se tenho 1000 tarefas e 10 workers, cada um processa ~100.\n**TÃ³pico (Topic) - Modelo Pub/Sub:**\nUma mensagem Ã© entregue a TODOS os consumidores inscritos.\nÃštil para: Broadcasting de eventos. Quando \"ContratoAssinado\" acontece, vÃ¡rios serviÃ§os precisam reagir.\n**No RabbitMQ:**\n- Fila: tipo de exchange \"direct\" ou \"default\"\n- TÃ³pico: exchange tipo \"fanout\" ou \"topic\"\n**No Kafka:**\n- Tudo Ã© tÃ³pico, mas com consumer groups posso simular fila (sÃ³ um consumer do grupo processa cada mensagem)",
        "code": "                      â”Œâ”€â”€â–º Consumidor 1 (recebe cÃ³pia)\nProdutor â”€â”€â–º [TÃ³pico]â”€â”¼â”€â”€â–º Consumidor 2 (recebe cÃ³pia)\n                      â””â”€â”€â–º Consumidor 3 (recebe cÃ³pia)"
      },
      {
        "id": "q-5-3",
        "title": "Como garantir que mensagens sejam processadas com sucesso?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Garantir processamento confiÃ¡vel requer vÃ¡rias estratÃ©gias:\n**1. Acknowledgment (ACK):**\nSÃ³ confirmo recebimento apÃ³s processar com sucesso. Se der erro, a mensagem volta para a fila.\n**2. Dead Letter Queue (DLQ):**\nMensagens que falharam apÃ³s mÃºltiplas tentativas vÃ£o para uma fila especial para anÃ¡lise posterior.\n**3. Retry Policies com Backoff Exponencial:**\nPrimeira tentativa imediata, segunda apÃ³s 1s, terceira apÃ³s 2s, quarta apÃ³s 4s...\n**4. IdempotÃªncia:**\nProcessar a mesma mensagem mÃºltiplas vezes nÃ£o causa efeitos colaterais. Uso IDs Ãºnicos:\n**5. TransaÃ§Ãµes (Outbox Pattern):**\nGarante atomicidade entre salvar no banco e publicar mensagem:",
        "code": "@Transactional\npublic void criarContrato(Contrato contrato) {\n    repository.save(contrato);\n    outboxRepository.save(new Outbox(\"ContratoEvent\", contrato));\n    // Processo separado publica do Outbox para Kafka\n}"
      }
    ]
  },
  {
    "id": "section-6",
    "title": "â˜• 6. JAVA CORE E COLLECTIONS",
    "questions": [
      {
        "id": "q-6-0",
        "title": "Explique a diferenÃ§a entre List, Set e Map.",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "**List:**\nColeÃ§Ã£o ordenada que permite elementos duplicados e acesso por Ã­ndice.\nImplementaÃ§Ãµes:\n- **ArrayList:** Acesso rÃ¡pido O(1), inserÃ§Ã£o no meio O(n)\n- **LinkedList:** InserÃ§Ã£o rÃ¡pida O(1) no inÃ­cio/fim, acesso O(n)\n**Set:**\nColeÃ§Ã£o que nÃ£o permite duplicatas.\nImplementaÃ§Ãµes:\n- **HashSet:** Sem ordem, mais rÃ¡pido\n- **LinkedHashSet:** MantÃ©m ordem de inserÃ§Ã£o\n- **TreeSet:** Ordenado naturalmente ou por comparator\n**Map:**\nArmazena pares chave-valor, onde as chaves sÃ£o Ãºnicas.\nImplementaÃ§Ãµes:\n- **HashMap:** Mais comum, sem ordem\n- **LinkedHashMap:** MantÃ©m ordem de inserÃ§Ã£o\n- **TreeMap:** Ordenado por chave",
        "code": "Map<CPF, Cliente> clientes = new HashMap<>();\nclientes.put(cpf, cliente);\nCliente c = clientes.get(cpf);"
      },
      {
        "id": "q-6-1",
        "title": "O que sÃ£o exceÃ§Ãµes tratÃ¡veis e nÃ£o tratÃ¡veis?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Java divide exceÃ§Ãµes em duas categorias principais:\n**Checked Exceptions (TratÃ¡veis):**\n- Herdam de `Exception` (exceto RuntimeException)\n- Compilador OBRIGA tratamento (try/catch ou throws)\n- Representam problemas recuperÃ¡veis\n- Exemplos: `IOException`, `SQLException`, `FileNotFoundException`\n**Unchecked Exceptions (NÃ£o TratÃ¡veis):**\n- Herdam de `RuntimeException`\n- Compilador NÃƒO obriga tratamento\n- Geralmente indicam erros de programaÃ§Ã£o\n- Exemplos: `NullPointerException`, `IllegalArgumentException`, `IndexOutOfBoundsException`\n**Best Practices:**\n1. **Use Unchecked para erros de domÃ­nio:**\n2. **Wrapped Exceptions:**\n3. **NÃ£o use exceÃ§Ãµes para fluxo de controle:**",
        "code": "// Ruim\ntry {\n    return lista.get(0);\n} catch (IndexOutOfBoundsException e) {\n    return null;\n}\n\n// Bom\nreturn lista.isEmpty() ? null : lista.get(0);"
      }
    ]
  },
  {
    "id": "section-7",
    "title": "ğŸŒ 7. HTTP, REST E COMUNICAÃ‡ÃƒO",
    "questions": [
      {
        "id": "q-7-intro",
        "title": "O que Ã© HTTP e como funciona a comunicaÃ§Ã£o cliente-servidor?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "HTTP (HyperText Transfer Protocol) Ã© o protocolo de comunicaÃ§Ã£o que permite a troca de informaÃ§Ãµes na web. Funciona no modelo request-response:\n\n**Como funciona a comunicaÃ§Ã£o:**\n1. **Cliente** (navegador, app, outra API) envia uma **Request** para o servidor\n2. **Servidor** processa a requisiÃ§Ã£o\n3. **Servidor** envia uma **Response** de volta ao cliente\n\n**Estrutura de uma Request HTTP:**\n- **MÃ©todo:** GET, POST, PUT, DELETE (a aÃ§Ã£o desejada)\n- **URL:** O recurso sendo acessado (`/clientes/123`)\n- **Headers:** Metadados (Content-Type, Authorization)\n- **Body:** Dados enviados (para POST/PUT)\n\n**Estrutura de uma Response HTTP:**\n- **Status Code:** 200 OK, 404 Not Found, 500 Error\n- **Headers:** Metadados da resposta\n- **Body:** Dados retornados (JSON, HTML)\n\n**CaracterÃ­sticas importantes:**\n- **Stateless:** Cada request Ã© independente, servidor nÃ£o guarda estado\n- **Baseado em texto:** Mensagens sÃ£o legÃ­veis (diferente de protocolos binÃ¡rios)\n- **Porta padrÃ£o:** 80 (HTTP) ou 443 (HTTPS)",
        "code": "â”€â”€ REQUEST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nPOST /clientes HTTP/1.1\nHost: api.consignadohub.com\nContent-Type: application/json\nAuthorization: Bearer <token>\n\n{\"nome\": \"Maria\", \"cpf\": \"12345678901\"}\n\nâ”€â”€ RESPONSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHTTP/1.1 201 Created\nContent-Type: application/json\nLocation: /clientes/abc-123\n\n{\"id\": \"abc-123\", \"nome\": \"Maria\"}"
      },
      {
        "id": "q-7-0",
        "title": "Quais sÃ£o os principais mÃ©todos HTTP e quando usar cada um?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Os principais mÃ©todos HTTP definem a aÃ§Ã£o a ser executada sobre um recurso. Cada mÃ©todo tem uma semÃ¢ntica especÃ­fica:\n\n**GET:** Buscar/ler dados. NÃ£o altera estado. Seguro e idempotente.\n\n**POST:** Criar novo recurso. Cada chamada pode criar um recurso novo. NÃƒO Ã© idempotente.\n\n**PUT:** Atualizar/substituir recurso completo. Idempotente - chamar vÃ¡rias vezes produz o mesmo resultado.\n\n**PATCH:** Atualizar parcialmente um recurso solicitado. SÃ³ envia os campos a alterar.\n\n**DELETE:** Remover recurso. Idempotente - deletar algo que jÃ¡ foi deletado nÃ£o causa erro.",
        "table": {
          "headers": [
            "MÃ©todo",
            "AÃ§Ã£o",
            "Idempotente?",
            "Exemplo"
          ],
          "rows": [
            [
              "**GET**",
              "Buscar/Ler",
              "âœ… Sim",
              "`GET /clientes/123`"
            ],
            [
              "**POST**",
              "Criar",
              "âŒ NÃ£o",
              "`POST /clientes` (body com dados)"
            ],
            [
              "**PUT**",
              "Atualizar completo",
              "âœ… Sim",
              "`PUT /clientes/123` (substitui tudo)"
            ],
            [
              "**PATCH**",
              "Atualizar parcial",
              "âœ… Sim",
              "`PATCH /clientes/123` (sÃ³ campos enviados)"
            ],
            [
              "**DELETE**",
              "Remover",
              "âœ… Sim",
              "`DELETE /clientes/123`"
            ]
          ]
        },
        "code": "PUT /clientes/123 { \"nome\": \"JoÃ£o\" }  â†’ Sempre deixa nome = JoÃ£o\nPUT /clientes/123 { \"nome\": \"JoÃ£o\" }  â†’ Mesmo resultado (idempotente)\n\nPOST /clientes { \"nome\": \"JoÃ£o\" }  â†’ Cria cliente ID 1\nPOST /clientes { \"nome\": \"JoÃ£o\" }  â†’ Cria cliente ID 2 (NÃƒO idempotente)",
        "tip": "IdempotÃªncia Ã© crucial em sistemas distribuÃ­dos. Se o cliente nÃ£o recebe resposta (timeout), ele pode reenviar. Com operaÃ§Ãµes idempotentes, reenviar Ã© seguro."
      },
      {
        "id": "q-7-1",
        "title": "Quais sÃ£o os principais cÃ³digos de status HTTP?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**CÃ³digos que uso no ConsignadoHub:**\n| SituaÃ§Ã£o | CÃ³digo | Por quÃª |\n|----------|--------|---------|\n| Cliente cadastrado | `201 Created` | Recurso criado |\n| Cliente encontrado | `200 OK` | Sucesso |\n| CPF invÃ¡lido | `422 Unprocessable` | Dados vÃ¡lidos sintaticamente, mas invÃ¡lidos semanticamente |\n| Cliente nÃ£o encontrado | `404 Not Found` | Recurso nÃ£o existe |\n| CPF jÃ¡ cadastrado | `409 Conflict` | Conflito de negÃ³cio |\n| Erro interno | `500 Internal` | Algo quebrou no servidor |",
        "table": {
          "headers": [
            "Faixa",
            "Categoria",
            "CÃ³digos Comuns"
          ],
          "rows": [
            [
              "**2xx**",
              "Sucesso",
              "200 OK, 201 Created, 204 No Content"
            ],
            [
              "**3xx**",
              "Redirecionamento",
              "301 Moved, 304 Not Modified"
            ],
            [
              "**4xx**",
              "Erro do Cliente",
              "400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict, 422 Unprocessable"
            ],
            [
              "**5xx**",
              "Erro do Servidor",
              "500 Internal Error, 502 Bad Gateway, 503 Service Unavailable"
            ]
          ]
        }
      },
      {
        "id": "q-7-2",
        "title": "O que Ã© REST e quais sÃ£o as boas prÃ¡ticas?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "REST (Representational State Transfer) Ã© um estilo arquitetural para APIs.\n**PrincÃ­pios REST:**\n1. **Stateless:** Cada request contÃ©m toda informaÃ§Ã£o necessÃ¡ria (sem sessÃ£o no servidor)\n2. **Client-Server:** SeparaÃ§Ã£o clara\n3. **Uniform Interface:** URLs representam recursos, verbos HTTP representam aÃ§Ãµes\n4. **Cacheable:** Respostas podem ser cacheadas\n**Boas prÃ¡ticas de URLs:**\n**Boas prÃ¡ticas de resposta:**",
        "code": "// Sucesso\n{\n  \"id\": \"123\",\n  \"cpf\": \"529.982.247-25\",\n  \"nome\": \"Maria Silva\"\n}\n\n// Erro padronizado\n{\n  \"code\": \"CPF_INVALIDO\",\n  \"message\": \"CPF deve ter 11 dÃ­gitos\",\n  \"field\": \"cpf\",\n  \"timestamp\": \"2026-01-08T10:00:00\"\n}"
      },
      {
        "id": "q-7-3",
        "title": "Quando usar comunicaÃ§Ã£o sÃ­ncrona vs assÃ­ncrona?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Use SÃNCRONA quando:**\n- Precisa de resposta imediata\n- OperaÃ§Ã£o simples e rÃ¡pida\n- ValidaÃ§Ã£o que bloqueia o fluxo\n- UI esperando resposta\n**Exemplos:**\n**Use ASSÃNCRONA quando:**\n- OperaÃ§Ã£o demorada (segundos/minutos)\n- NÃ£o precisa de resposta imediata\n- Desacoplar serviÃ§os\n- Alta carga (buffer de mensagens)\n- MÃºltiplos consumidores do mesmo evento\n**Exemplos:**\n**DecisÃ£o no ConsignadoHub:**\n| OperaÃ§Ã£o | Tipo | Por quÃª |\n|----------|------|---------|\n| Cadastrar cliente | SÃ­ncrono | UI espera confirmaÃ§Ã£o |\n| Buscar cliente | SÃ­ncrono | Precisa do dado agora |\n| Simular emprÃ©stimo | SÃ­ncrono | Mostra resultado na tela |\n| Enviar email | AssÃ­ncrono | Pode demorar, nÃ£o bloqueia |\n| Notificar INSS | AssÃ­ncrono | ServiÃ§o externo, desacopla |\n| Processar averbaÃ§Ã£o | AssÃ­ncrono | Processo longo |",
        "table": {
          "headers": [
            "Aspecto",
            "SÃ­ncrona (REST/gRPC)",
            "AssÃ­ncrona (Kafka/RabbitMQ)"
          ],
          "rows": [
            [
              "**Resposta**",
              "Imediata",
              "Eventual"
            ],
            [
              "**Acoplamento**",
              "Alto",
              "Baixo"
            ],
            [
              "**Disponibilidade**",
              "Depende do destino",
              "Desacoplado"
            ],
            [
              "**Complexidade**",
              "Menor",
              "Maior"
            ],
            [
              "**Rastreabilidade**",
              "FÃ¡cil",
              "Requer correlationId"
            ]
          ]
        },
        "code": "ContratoAssinado â†’ [Kafka] â†’ EmailService (envia email)\n                          â†’ AuditoriaService (registra log)\n                          â†’ INSSService (averba)"
      },
      {
        "id": "q-7-4",
        "title": "O que acontece se o serviÃ§o destino estiver fora do ar?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**ComunicaÃ§Ã£o SÃ­ncrona:**\n- Request falha imediatamente\n- Cliente recebe erro 5xx\n- Precisa de: Circuit Breaker, Retry, Fallback\n**ComunicaÃ§Ã£o AssÃ­ncrona:**\n- Mensagem fica na fila esperando\n- Consumer processa quando voltar\n- Sistema origem nÃ£o Ã© afetado\n**Por isso, para integraÃ§Ãµes externas (INSS, bancos), prefiro assÃ­ncrono** - nÃ£o fico refÃ©m da disponibilidade do outro sistema.",
        "code": "Produtor â†’ [Fila] â†’ Consumer (offline)\n                    â†“\n           Mensagem espera\n                    â†“\n           Consumer volta â†’ Processa"
      },
      {
        "id": "q-7-5",
        "title": "DiferenÃ§a entre REST e gRPC?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "**Quando usar REST:**\n- APIs pÃºblicas\n- IntegraÃ§Ã£o com frontend\n- Quando legibilidade importa\n- Time nÃ£o conhece gRPC\n**Quando usar gRPC:**\n- ComunicaÃ§Ã£o interna entre microserviÃ§os\n- Alta performance necessÃ¡ria\n- Streaming de dados\n- Contratos fortemente tipados",
        "table": {
          "headers": [
            "Aspecto",
            "REST",
            "gRPC"
          ],
          "rows": [
            [
              "Protocolo",
              "HTTP/1.1 (texto)",
              "HTTP/2 (binÃ¡rio)"
            ],
            [
              "Formato",
              "JSON (legÃ­vel)",
              "Protocol Buffers (compacto)"
            ],
            [
              "Performance",
              "Boa",
              "Excelente"
            ],
            [
              "Streaming",
              "Limitado",
              "Bidirecional nativo"
            ],
            [
              "Contrato",
              "OpenAPI/Swagger",
              ".proto files"
            ],
            [
              "Browser",
              "âœ… Suportado",
              "âš ï¸ Limitado"
            ]
          ]
        }
      }
    ]
  },
  {
    "id": "section-8",
    "title": "ğŸƒ 8. SPRING FRAMEWORK",
    "questions": [
      {
        "id": "q-8-0",
        "title": "O que Ã© InversÃ£o de Controle (IoC) e InjeÃ§Ã£o de DependÃªncia (DI)?",
        "tags": [
          "bÃ¡sico",
          "importante"
        ],
        "content": "**InversÃ£o de Controle (IoC):**\nÃ‰ um princÃ­pio onde o controle da criaÃ§Ã£o e gerenciamento de objetos Ã© \"invertido\". Em vez de eu criar os objetos que preciso, um container externo (no caso, o Spring) faz isso por mim.\nSem IoC:\nCom IoC:\n**InjeÃ§Ã£o de DependÃªncia (DI):**\nÃ‰ a FORMA como o IoC Ã© implementado. O container injeta as dependÃªncias necessÃ¡rias nas classes.\n**Tipos de injeÃ§Ã£o:**\n1. **Por Construtor (Preferido):**\nVantagens: imutabilidade, dependÃªncias explÃ­citas, fÃ¡cil de testar, falha rÃ¡pida.\n2. **Por Setter:**\nQuando usar: dependÃªncias opcionais.\n3. **Por Campo (Evitar):**\nDesvantagens: difÃ­cil de testar, dependÃªncias ocultas.\n**Por que usar DI:**\n- Desacoplamento\n- Testabilidade (posso injetar mocks)\n- ConfiguraÃ§Ã£o centralizada\n- CÃ³digo mais limpo",
        "code": "@Service\npublic class ClienteService {\n    @Autowired\n    private ClienteRepository repository;\n}"
      }
    ]
  },
  {
    "id": "section-9",
    "title": "ğŸ§ª 9. TESTES",
    "questions": [
      {
        "id": "q-9-0",
        "title": "O que Ã© TDD e como vocÃª aplica?",
        "tags": [
          "bÃ¡sico",
          "importante"
        ],
        "content": "TDD (Test-Driven Development) Ã© uma metodologia onde escrevemos o teste ANTES da implementaÃ§Ã£o.\n**Ciclo TDD:**\n1. ğŸ”´ **RED:** Escrever um teste que falha\n2. ğŸŸ¢ **GREEN:** Escrever o mÃ­nimo de cÃ³digo para passar\n3. ğŸ”µ **REFACTOR:** Melhorar o cÃ³digo mantendo testes verdes\n**Exemplo prÃ¡tico no meu projeto:**\n**BenefÃ­cios que experimento:**\n- CÃ³digo testÃ¡vel por design\n- DocumentaÃ§Ã£o viva (testes explicam comportamento)\n- ConfianÃ§a para refatorar\n- Menos bugs em produÃ§Ã£o\n**No ConsignadoHub:** 78 testes, todos escritos antes da implementaÃ§Ã£o.",
        "code": "// 1. RED - Teste primeiro\n@Test\nvoid deveCriarCPFValido() {\n    CPF cpf = new CPF(\"52998224725\");\n    assertThat(cpf.valor()).isEqualTo(\"52998224725\");\n}\n\n@Test\nvoid deveRejeitarCPFNulo() {\n    assertThatThrownBy(() -> new CPF(null))\n        .isInstanceOf(DomainException.class);\n}\n\n// Testes falham porque CPF nÃ£o existe ainda\n\n// 2. GREEN - ImplementaÃ§Ã£o mÃ­nima\npublic record CPF(String valor) {\n    public CPF {\n        if (valor == null) throw DomainException.required(\"cpf\");\n    }\n}\n\n// Testes passam!\n\n// 3. REFACTOR - Melhorar\npublic record CPF(String valor) {\n    public CPF {\n        if (valor == null) throw DomainException.required(\"cpf\");\n        valor = valor.replaceAll(\"[^0-9]\", \"\"); // Remove formataÃ§Ã£o\n        if (!isValid(valor)) throw DomainException.invalidField(\"cpf\", \"invÃ¡lido\");\n    }\n}",
        "tip": "No ConsignadoHub: 78 testes, todos escritos antes da implementaÃ§Ã£o."
      }
    ]
  },
  {
    "id": "section-10",
    "title": "ğŸ³ 10. DEVOPS E DEPLOY",
    "questions": [
      {
        "id": "q-10-0",
        "title": "Boas prÃ¡ticas para deploy seguro",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**1. Feature Flags:**\nCÃ³digo vai para produÃ§Ã£o DESLIGADO. Posso ligar/desligar sem redeploy.\n**2. Canary Release:**\nLibera para percentual pequeno de usuÃ¡rios primeiro:\n- 1% por 1 hora\n- 10% por 4 horas\n- 50% por 1 dia\n- 100%\nSe mÃ©tricas degradarem, faz rollback automÃ¡tico.\n**3. Blue/Green Deployment:**\nDois ambientes idÃªnticos. Deploy no ambiente inativo, troca o roteamento.\n**4. Health Checks:**\nKubernetes/Load balancer sÃ³ roteia para instÃ¢ncias saudÃ¡veis.\n**5. Circuit Breaker:**\nSe dependÃªncia estÃ¡ degradada, falha rÃ¡pido em vez de timeout.\n**6. Rollback Automatizado:**\nSe taxa de erro aumentar apÃ³s deploy, reverte automaticamente.\n**7. Smoke Tests PÃ³s-Deploy:**\nTestes automÃ¡ticos que validam funcionalidades crÃ­ticas apÃ³s deploy.",
        "code": "livenessProbe:\n  httpGet:\n    path: /actuator/health/liveness\n    port: 8080\nreadinessProbe:\n  httpGet:\n    path: /actuator/health/readiness\n    port: 8080"
      },
      {
        "id": "q-10-1",
        "title": "Como funciona o versionamento de aplicaÃ§Ãµes? (Semantic Versioning)",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Uso Semantic Versioning (SemVer) no formato `MAJOR.MINOR.PATCH`:\n**Quando incrementar cada nÃºmero:**\n**Regras importantes:**\n- Quando incrementa MINOR, PATCH volta para 0\n- Quando incrementa MAJOR, MINOR e PATCH voltam para 0\n- Adicionar campo opcional Ã© MINOR (nÃ£o quebra)\n- Remover campo Ã© MAJOR (quebra)\n**VersÃµes especiais:**\n| Sufixo | Significado | Exemplo |\n|--------|-------------|---------|\n| `-SNAPSHOT` | Em desenvolvimento | `1.5.0-SNAPSHOT` |\n| `-alpha` | Muito instÃ¡vel | `2.0.0-alpha.1` |\n| `-beta` | Testando features | `2.0.0-beta.3` |\n| `-RC` | Release Candidate | `2.0.0-RC1` |\n**Resposta resumida para entrevista:**\n*\"Uso Semantic Versioning - MAJOR.MINOR.PATCH. PATCH para bug fixes, MINOR para features novas que sÃ£o backward compatible, MAJOR para breaking changes. Por exemplo, se adiciono um campo opcional na API, Ã© MINOR. Se removo um campo, Ã© MAJOR porque quebra clientes existentes. No CI/CD, usamos tags no Git (v1.2.3) e o pipeline faz o build automaticamente.\"*",
        "code": "  2  .  1  .  3\n  â”‚     â”‚     â”‚\n  â”‚     â”‚     â””â”€â”€ PATCH: Bug fixes (correÃ§Ãµes)\n  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€ MINOR: Novas features (sem quebrar)\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAJOR: Breaking changes (quebra compatibilidade)",
        "table": {
          "headers": [
            "SituaÃ§Ã£o",
            "Exemplo",
            "Por quÃª"
          ],
          "rows": [
            [
              "**PATCH** (1.0.0 â†’ 1.0.1)",
              "Fix de null pointer",
              "Bug fix, nÃ£o muda comportamento"
            ],
            [
              "**MINOR** (1.0.1 â†’ 1.1.0)",
              "Novo endpoint",
              "Nova feature, compatÃ­vel com versÃ£o anterior"
            ],
            [
              "**MAJOR** (1.1.0 â†’ 2.0.0)",
              "Removeu campo obrigatÃ³rio",
              "Breaking change, quebra clientes existentes"
            ]
          ]
        }
      }
    ]
  },
  {
    "id": "section-11",
    "title": "ğŸ’¡ 11. PERGUNTAS COMPORTAMENTAIS",
    "questions": [
      {
        "id": "q-11-0",
        "title": "Me fale sobre um desafio tÃ©cnico que vocÃª resolveu",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Resposta 1 - ConsolidaÃ§Ã£o de ExceÃ§Ãµes:**\n*\"No meu projeto de crÃ©dito consignado, enfrentei o desafio de ter 16 classes de exceÃ§Ã£o diferentes - InvalidCPFException, InvalidEmailException, etc. Cada Value Object tinha sua prÃ³pria exceÃ§Ã£o.*\n*O problema Ã© que isso gerava muito cÃ³digo duplicado e dificultava o tratamento centralizado de erros.*\n*A soluÃ§Ã£o foi consolidar em apenas 3 exceÃ§Ãµes com factory methods: DomainException, BusinessException e NotFoundException. Cada uma com cÃ³digo de erro padronizado.*\n*O aprendizado foi que Ã s vezes menos classes Ã© melhor - cÃ³digos de erro bem definidos sÃ£o mais flexÃ­veis que hierarquias de exceÃ§Ã£o complexas.\"*\n**Resposta 2 - Bug de CPF com Zeros Ã  Esquerda:**\n*\"TÃ­nhamos um bug onde clientes do Norte/Nordeste nÃ£o conseguiam se cadastrar. O erro era 'CPF invÃ¡lido'.*\n*Descobri que CPFs que comeÃ§am com zero estavam perdendo o zero quando salvos como nÃºmero no banco. Quando reconstituÃ­do, virava 10 dÃ­gitos em vez de 11.*\n*A soluÃ§Ã£o foi usar String em vez de Long, criar um Value Object imutÃ¡vel que sempre mantÃ©m os zeros, e adicionar testes especÃ­ficos.*\n*Aprendi que CPF, CNPJ e CEP devem sempre ser tratados como Strings.\"*\n**Resposta 3 - Problema N+1:**\n*\"O endpoint de listar clientes demorava 3 segundos para 100 registros. Em produÃ§Ã£o com 10.000, dava timeout.*\n*Habilitei logs de SQL e vi 101 queries - o clÃ¡ssico problema N+1. Para cada cliente, uma query buscando benefÃ­cios.*\n*A soluÃ§Ã£o foi usar JOIN FETCH e @EntityGraph. Para listagens simples, criei DTOs de projeÃ§Ã£o.*\n*Tempo caiu de 3s para 50ms. Aprendi a sempre monitorar queries quando uso ORM.\"*\n**Resposta 4 - TransaÃ§Ã£o Sem Rollback:**\n*\"Clientes eram cadastrados mesmo quando o envio de email falhava. Deveria ser atÃ´mico.*\n*O mÃ©todo tinha @Transactional, mas a exceÃ§Ã£o era IOException (checked). Spring sÃ³ faz rollback para RuntimeException por padrÃ£o.*\n*Adicionei rollbackFor = Exception.class e refatorei exceÃ§Ãµes de domÃ­nio para RuntimeException.*\n*Criei uma regra: exceÃ§Ãµes de ",
        "tip": "No meu projeto de crÃ©dito consignado, enfrentei o desafio de ter 16 classes de exceÃ§Ã£o diferentes - InvalidCPFException, InvalidEmailException, etc. Cada Value Object tinha sua prÃ³pria exceÃ§Ã£o."
      },
      {
        "id": "q-11-1",
        "title": "O que vocÃª aprendeu recentemente?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Resposta modelo:**\n*\"Recentemente desenvolvi um projeto completo de crÃ©dito consignado INSS onde aprendi a aplicar vÃ¡rios conceitos na prÃ¡tica:*\n*Arquitetura Hexagonal - separei claramente Domain, Application e Adapters. O domÃ­nio nÃ£o conhece Spring ou JPA.*\n*TDD rigoroso - 78 testes, todos escritos antes da implementaÃ§Ã£o. Isso me deu confianÃ§a para refatorar.*\n*CQS vs CQRS - entendi a diferenÃ§a prÃ¡tica. CQS Ã© separar interfaces de leitura/escrita no mesmo banco. CQRS Ã© ter bancos diferentes.*\n*Tratamento de exceÃ§Ãµes enterprise - consolidar exceÃ§Ãµes com cÃ³digos padronizados em vez de muitas classes.*\n*O maior aprendizado foi que teoria sÃ³ se consolida com prÃ¡tica. Eu conhecia esses conceitos, mas implementar do zero mostrou os trade-offs reais.\"*"
      },
      {
        "id": "q-11-2",
        "title": "ğŸ’¡ Dicas para Contar Desafios TÃ©cnicos",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "1. **Use a estrutura STAR:** SituaÃ§Ã£o, Tarefa, AÃ§Ã£o, Resultado\n2. **Seja especÃ­fico com nÃºmeros:** \"caiu de 3s para 50ms\" Ã© convincente\n3. **Mostre aprendizado:** O que vocÃª levou para projetos futuros\n4. **NÃ£o invente tecnologias que nÃ£o conhece:** VocÃª serÃ¡ questionado\n5. **Prepare 3-4 histÃ³rias:** Diferentes tipos de problemas (performance, bugs, arquitetura)"
      }
    ]
  },
  {
    "id": "section-13",
    "title": "âš–ï¸ 13. PERGUNTAS DE DECISÃƒO (TRADE-OFFS)",
    "questions": [
      {
        "id": "q-13-0",
        "title": "Monolito vs MicroserviÃ§os - quando migrar?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Comece com Monolito quando:**\n- MVP, prova de conceito\n- Time pequeno (< 10 devs)\n- DomÃ­nio nÃ£o estÃ¡ bem definido\n- NÃ£o tem observabilidade madura\n**Migre para MicroserviÃ§os quando:**\n- Times precisam de autonomia\n- Partes do sistema tÃªm escalas muito diferentes\n- Deploy independente Ã© crÃ­tico\n- JÃ¡ entende bem os bounded contexts\n**No ConsignadoHub:**\n*\"Comecei como monolito modular. Cada mÃ³dulo (customer, simulation, contract) Ã© um bounded context separado. Quando precisar escalar, extraio para microserviÃ§o sem reescrever - a separaÃ§Ã£o jÃ¡ existe.\"*",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-1",
        "title": "HeranÃ§a vs ComposiÃ§Ã£o - quando usar cada?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Use HeranÃ§a quando:**\n- Existe relaÃ§Ã£o \"Ã© um\" clara (ContaCorrente Ã‰ UMA Conta)\n- Quer compartilhar implementaÃ§Ã£o entre subclasses\n- Hierarquia Ã© estÃ¡vel e nÃ£o vai mudar muito\n**Use ComposiÃ§Ã£o quando:**\n- Existe relaÃ§Ã£o \"tem um\" (Cliente TEM EndereÃ§o)\n- Precisa de flexibilidade (trocar comportamento em runtime)\n- Quer evitar acoplamento forte\n**Regra geral:** Prefira composiÃ§Ã£o. Use heranÃ§a sÃ³ quando realmente faz sentido.",
        "code": "// HeranÃ§a: \"Ã© um\"\nclass ContaCorrente extends Conta { }\n\n// ComposiÃ§Ã£o: \"tem um\"\nclass Cliente {\n    private Endereco endereco;  // Composto, nÃ£o herdado\n    private List<Beneficio> beneficios;\n}"
      },
      {
        "id": "q-13-2",
        "title": "Exception vs Optional - quando usar cada?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Lance Exception quando:**\n- SituaÃ§Ã£o Ã© realmente excepcional\n- NÃ£o deveria acontecer em fluxo normal\n- Ã‰ um erro de programaÃ§Ã£o ou violaÃ§Ã£o de regra\n**Retorne Optional quando:**\n- AusÃªncia de valor Ã© esperada e vÃ¡lida\n- MÃ©todo de busca que pode nÃ£o encontrar\n- Quero forÃ§ar o chamador a tratar o caso vazio\n**No ConsignadoHub:**\n- `buscarPorCpf()` â†’ Retorna `Optional` (pode nÃ£o existir)\n- ValidaÃ§Ã£o de CPF invÃ¡lido â†’ LanÃ§a `DomainException` (erro)",
        "code": "Optional<Cliente> buscarPorCpf(CPF cpf);\n\n// Chamador Ã© obrigado a tratar\ncliente.orElseThrow(() -> NotFoundException.cliente(cpf));",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-3",
        "title": "DTO vs Entity direto na API - por que usar DTO?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Problemas de expor Entity direto:**\n- Vaza estrutura interna do domÃ­nio\n- MudanÃ§a no banco quebra a API\n- Serializa relacionamentos indesejados (N+1)\n- Campos sensÃ­veis expostos (senha, tokens)\n**BenefÃ­cios do DTO:**\n- Contrato de API estÃ¡vel\n- Controle do que Ã© exposto\n- Evita serializaÃ§Ã£o de lazy loading\n- Pode ter formato diferente do domÃ­nio\n**No ConsignadoHub:**\n*\"Uso Commands (entrada) e Responses (saÃ­da). O Controller converte DTO â†’ Domain e Domain â†’ DTO via Mappers.\"*",
        "code": "// DTO de entrada (Command)\nrecord CadastrarClienteRequest(String cpf, String nome, String email);\n\n// DTO de saÃ­da (Response)\nrecord ClienteResponse(UUID id, String cpfFormatado, String nome);\n\n// Entity (DomÃ­nio) - nunca exposta\nclass Cliente {\n    private ClienteId id;\n    private CPF cpf;\n    private String nome;\n}",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-4",
        "title": "Lazy vs Eager Loading - qual Ã© o padrÃ£o correto?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**PadrÃ£o: SEMPRE LAZY**\n**Por que Lazy?**\n- NÃ£o carrega dados desnecessÃ¡rios\n- Evita N+1 acidental\n- Melhor performance inicial\n**Quando preciso dos dados relacionados:**\n**Regra:** Configure LAZY, use FETCH quando precisar explicitamente.",
        "code": "// JOIN FETCH quando sei que vou usar\n@Query(\"SELECT c FROM Cliente c JOIN FETCH c.beneficios WHERE c.id = :id\")\nCliente buscarComBeneficios(@Param(\"id\") Long id);\n\n// Ou @EntityGraph\n@EntityGraph(attributePaths = {\"beneficios\"})\nList<Cliente> findAll();"
      },
      {
        "id": "q-13-5",
        "title": "Cache Local vs DistribuÃ­do - quando usar cada?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Use Cache Local quando:**\n- Dados mudam raramente (configuraÃ§Ãµes, taxas)\n- Pode ter inconsistÃªncia temporÃ¡ria entre pods\n- Alta frequÃªncia de leitura, mesmo dado\n**Use Cache DistribuÃ­do quando:**\n- Precisa de consistÃªncia entre instÃ¢ncias\n- SessÃ£o de usuÃ¡rio\n- Dados que mudam frequentemente\n- Rate limiting\n**No ConsignadoHub:**\n*\"Taxas de juros e configuraÃ§Ãµes: cache local (Caffeine) com TTL de 5 minutos. SessÃ£o do atendente: Redis (precisa consistÃªncia).\"*",
        "table": {
          "headers": [
            "Aspecto",
            "Cache Local (Caffeine)",
            "Cache DistribuÃ­do (Redis)"
          ],
          "rows": [
            [
              "Performance",
              "Ultra rÃ¡pida (memÃ³ria)",
              "RÃ¡pida (rede)"
            ],
            [
              "ConsistÃªncia",
              "Por instÃ¢ncia",
              "Compartilhado"
            ],
            [
              "Escalabilidade",
              "Cada pod tem sua cÃ³pia",
              "Uma fonte de verdade"
            ],
            [
              "InvalidaÃ§Ã£o",
              "Complexa entre pods",
              "Simples (centralizado)"
            ]
          ]
        },
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-6",
        "title": "Event Sourcing vs CRUD - quando vale a complexidade?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**CRUD tradicional:**\n- Salva estado atual\n- HistÃ³rico limitado (audit log separado)\n- Simples de entender e implementar\n- Maioria dos casos\n**Event Sourcing:**\n- Salva todos os eventos que aconteceram\n- Estado Ã© derivado dos eventos\n- HistÃ³rico completo nativo\n- Complexidade maior\n**Use Event Sourcing quando:**\n- Auditoria completa Ã© requisito legal (financeiro)\n- Precisa de \"time travel\" (ver estado em qualquer momento)\n- Eventos sÃ£o business value (nÃ£o sÃ³ tÃ©cnico)\n- N sistemas reagem aos mesmos eventos\n**Use CRUD quando:**\n- CRUD simples de cadastro\n- HistÃ³rico nÃ£o Ã© crÃ­tico\n- Time nÃ£o tem experiÃªncia com ES\n- MVP, precisa entregar rÃ¡pido\n**No ConsignadoHub:**\n*\"Cadastro de cliente: CRUD (simples, sem requisito de histÃ³rico). Contratos financeiros: Event Sourcing (regulaÃ§Ã£o exige trilha de auditoria completa).\"*",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-7",
        "title": "Saga Choreography vs Orchestration - qual padrÃ£o?",
        "tags": [
          "avanÃ§ado"
        ],
        "content": "**Choreography (coreografado):**\nCada serviÃ§o sabe reagir ao evento anterior.\n**Orchestration (orquestrado):**\nUm serviÃ§o central controla o fluxo.\n**Quando usar cada:**\n- **Choreography:** Fluxos simples (3-4 passos), times autÃ´nomos\n- **Orchestration:** Fluxos complexos, precisa de visibilidade, compensaÃ§Ãµes elaboradas\n**No ConsignadoHub:**\n*\"Para o fluxo de contrataÃ§Ã£o (contrato â†’ averbaÃ§Ã£o â†’ liberaÃ§Ã£o), usaria Orchestration porque o fluxo Ã© crÃ­tico, preciso de visibilidade clara, e as compensaÃ§Ãµes sÃ£o complexas.\"*",
        "table": {
          "headers": [
            "Aspecto",
            "Choreography",
            "Orchestration"
          ],
          "rows": [
            [
              "Controle",
              "Descentralizado",
              "Centralizador"
            ],
            [
              "Acoplamento",
              "Baixo",
              "MÃ©dio"
            ],
            [
              "Visibilidade",
              "DifÃ­cil de rastrear",
              "Fluxo claro"
            ],
            [
              "Complexidade",
              "DistribuÃ­da",
              "Centralizada"
            ],
            [
              "Ponto de falha",
              "Nenhum central",
              "Orquestrador"
            ]
          ]
        },
        "code": "Orquestrador --> ContratoService\n            --> AverbacaoService\n            --> LiberacaoService",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-13-8",
        "title": "Record vs Class - quando usar cada?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Record** (Java 14+): Classe imutÃ¡vel para transportar dados.\n**Class tradicional:** Quando precisa de mutabilidade ou comportamento complexo.\n**Quando usar Record:**\n- Value Objects (CPF, Dinheiro, Email)\n- DTOs (Request, Response, Command)\n- Dados imutÃ¡veis\n- Quando nÃ£o precisa de heranÃ§a\n**Quando usar Class:**\n- Entities com ciclo de vida (Cliente, Contrato)\n- Precisa de mutabilidade\n- HeranÃ§a Ã© necessÃ¡ria\n- LÃ³gica de negÃ³cio complexa\n**No ConsignadoHub:**\n*\"Uso Record para todos os Value Objects (CPF, Dinheiro, Email, DadosBancarios) e DTOs (ClienteResponse, CadastrarClienteCommand). Uso Class para entities como Cliente porque tem ciclo de vida e lÃ³gica de negÃ³cio.\"*",
        "code": "public class Cliente {\n    private String nome;\n    \n    public void alterarNome(String novoNome) {\n        this.nome = novoNome;  // MutÃ¡vel\n    }\n}",
        "table": {
          "headers": [
            "Aspecto",
            "Record",
            "Class"
          ],
          "rows": [
            [
              "Imutabilidade",
              "âœ… ForÃ§ada",
              "âŒ Opcional"
            ],
            [
              "Boilerplate",
              "MÃ­nimo",
              "Muito (ou Lombok)"
            ],
            [
              "HeranÃ§a",
              "âŒ NÃ£o pode",
              "âœ… Pode"
            ],
            [
              "SerializaÃ§Ã£o",
              "Simples",
              "Precisa configurar"
            ]
          ]
        },
        "tip": "No ConsignadoHub:"
      }
    ]
  },
  {
    "id": "section-14",
    "title": "ğŸš¨ 14. O QUE FAZER QUANDO... (TROUBLESHOOTING)",
    "questions": [
      {
        "id": "q-14-0",
        "title": "O que fazer quando uma mensagem Kafka dÃ¡ erro?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1: NÃ£o perder a mensagem**\n- Usar ACK manual (sÃ³ confirma apÃ³s processar)\n- Configurar retry policy\n**Passo 2: EstratÃ©gia de retry**\n**Passo 3: Dead Letter Queue (DLQ)**\n- Mensagens que falharam apÃ³s N tentativas vÃ£o para fila especial\n- AnÃ¡lise manual ou automÃ¡tica posterior\n- Alerta para o time investigar\n**Passo 4: Garantir idempotÃªncia**\n- Se a mesma mensagem for reprocessada, nÃ£o causa efeito duplicado\n- Usar campo de controle (idempotencyKey)",
        "code": "@KafkaListener(topics = \"contratos\")\npublic void processar(ContratoEvent evento) {\n    if (jaProcessado(evento.idempotencyKey())) {\n        log.info(\"Evento jÃ¡ processado, ignorando\");\n        return;\n    }\n    \n    try {\n        service.processar(evento);\n        marcarComoProcessado(evento.idempotencyKey());\n    } catch (Exception e) {\n        log.error(\"Erro processando: {}\", evento, e);\n        throw e;  // Kafka faz retry\n    }\n}"
      },
      {
        "id": "q-14-1",
        "title": "O que fazer quando vocÃª sobe uma alteraÃ§Ã£o com bug para produÃ§Ã£o?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1: Identificar impacto (1-2 min)**\n- Quantos usuÃ¡rios afetados?\n- Dados corrompidos?\n- Ã‰ crÃ­tico (financeiro, seguranÃ§a)?\n**Passo 2: DecisÃ£o rÃ¡pida**\n- **Rollback imediato:** Se impacto alto, voltar versÃ£o anterior\n- **Hotfix:** Se rollback nÃ£o Ã© possÃ­vel, corrigir e deploy rÃ¡pido\n- **Feature flag:** Se tiver, desligar a feature problemÃ¡tica\n**Passo 3: ComunicaÃ§Ã£o**\n- Avisar time/lideranÃ§a\n- Se afetou clientes, avisar suporte\n**Passo 4: Fix**\n**Passo 5: Post-mortem (depois)**\n- O que causou?\n- Por que nÃ£o pegamos antes?\n- Como evitar no futuro?",
        "code": "1. Reproduzir em ambiente local\n2. Escrever teste que falha (prova do bug)\n3. Corrigir\n4. Teste passa\n5. Deploy com monitoramento extra",
        "answer": "Primeiro avalio impacto. Se crÃ­tico, faÃ§o rollback imediato - melhor voltar para versÃ£o estÃ¡vel do que deixar produÃ§Ã£o quebrada. Depois investigo com calma, crio teste que reproduz o bug, corrijo, e faÃ§o deploy com monitoramento extra. No dia seguinte, faÃ§o post-mortem para melhorar o processo."
      },
      {
        "id": "q-14-2",
        "title": "O que fazer quando o banco de dados fica lento?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1: Identificar a query lenta**\n**Passo 2: Analisar com EXPLAIN ANALYZE**\n**PossÃ­veis causas e soluÃ§Ãµes:**\n**Passo 3: AÃ§Ãµes imediatas**\n- Matar query problemÃ¡tica se necessÃ¡rio\n- Reiniciar conexÃµes do pool\n- Escalar leitura (read replicas)",
        "code": "EXPLAIN ANALYZE SELECT * FROM clientes WHERE cpf = '123';",
        "table": {
          "headers": [
            "Causa",
            "DiagnÃ³stico",
            "SoluÃ§Ã£o"
          ],
          "rows": [
            [
              "Falta de Ã­ndice",
              "\"Seq Scan\" em tabela grande",
              "Criar Ã­ndice"
            ],
            [
              "Lock",
              "Muitas transaÃ§Ãµes esperando",
              "Verificar transaÃ§Ãµes longas"
            ],
            [
              "N+1",
              "Muitas queries similares",
              "JOIN FETCH, @BatchSize"
            ],
            [
              "Tabela muito grande",
              "MilhÃµes de registros",
              "PaginaÃ§Ã£o, particionamento"
            ],
            [
              "ConexÃµes esgotadas",
              "Pool cheio",
              "Aumentar pool, otimizar queries"
            ]
          ]
        },
        "answer": "Primeiro identifico qual query estÃ¡ lenta com pg_stat_activity. Depois rodo EXPLAIN ANALYZE para ver o plano de execuÃ§Ã£o. Geralmente Ã© falta de Ã­ndice (Seq Scan) ou problema de N+1. Adiciono Ã­ndice via migration ou otimizo a query com JOIN FETCH."
      },
      {
        "id": "q-14-3",
        "title": "O que fazer quando um serviÃ§o externo (API) fica fora do ar?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Se comunicaÃ§Ã£o Ã© SÃNCRONA:**\n1. **Circuit Breaker:** ApÃ³s N falhas, para de tentar\n2. **Timeout:** NÃ£o esperar infinitamente\n3. **Fallback:** Retornar valor default ou cached\n**Se comunicaÃ§Ã£o Ã© ASSÃNCRONA:**\n- Mensagem fica na fila esperando\n- Consumer processa quando serviÃ§o voltar\n- Sistema origem nÃ£o Ã© afetado",
        "code": "@CircuitBreaker(name = \"inss\", fallbackMethod = \"fallback\")\n@Retry(name = \"inss\", maxAttempts = 3)\n@Timeout(value = 5, unit = ChronoUnit.SECONDS)\npublic Averbacao consultar(String cpf) {\n    return inssClient.consultar(cpf);\n}\n\npublic Averbacao fallback(String cpf, Exception e) {\n    log.warn(\"INSS indisponÃ­vel, usando cache\");\n    return cacheService.buscarUltimaAverbacao(cpf);\n}",
        "answer": "Uso Circuit Breaker com Resilience4j. ApÃ³s 5 falhas, o circuito abre e retorna fallback imediatamente por 30 segundos. Isso evita cascata de falhas e timeout desnecessÃ¡rio. TambÃ©m tenho cache de Ãºltima consulta bem-sucedida para fallback."
      },
      {
        "id": "q-14-4",
        "title": "O que fazer quando a aplicaÃ§Ã£o estÃ¡ consumindo muita memÃ³ria?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1: Coletar heap dump**\n**Passo 2: Analisar com ferramenta**\n- Eclipse MAT (Memory Analyzer Tool)\n- VisualVM\n- JProfiler\n**Causas comuns:**\n**Passo 3: Monitorar**\n- Configurar alertas de memÃ³ria (> 80%)\n- Grafana/Prometheus com mÃ©tricas JVM",
        "code": "jmap -dump:format=b,file=heap.hprof <PID>",
        "table": {
          "headers": [
            "Causa",
            "Sintoma",
            "SoluÃ§Ã£o"
          ],
          "rows": [
            [
              "Memory leak",
              "Objetos que nunca sÃ£o liberados",
              "Encontrar referÃªncia que segura"
            ],
            [
              "Cache sem limite",
              "Cache cresce infinitamente",
              "Configurar TTL e tamanho mÃ¡ximo"
            ],
            [
              "Strings duplicadas",
              "Milhares de Strings iguais",
              "String.intern() ou pool"
            ],
            [
              "Listas grandes",
              "Carrega milhÃµes de registros",
              "PaginaÃ§Ã£o, stream"
            ]
          ]
        },
        "answer": "Coletaria um heap dump e analisaria com Eclipse MAT. Geralmente Ã© cache sem limite, lista carregando dados demais, ou leak de conexÃµes. TambÃ©m verifico se o problema Ã© no cÃ³digo ou se preciso aumentar memÃ³ria da JVM."
      },
      {
        "id": "q-14-5",
        "title": "O que fazer quando deploy em produÃ§Ã£o falha no meio?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**PrevenÃ§Ã£o (antes):**\n- Blue/Green deployment\n- Canary release\n- Feature flags\n- Health checks\n**Durante a falha:**\n1. **Rollback automÃ¡tico:** Se health check falha, volta versÃ£o anterior\n2. **Se nÃ£o tem automÃ¡tico:** kubectl rollout undo\n3. **Comunicar:** Avisar time que estÃ¡ revertendo\n**Depois:**\n- Verificar logs do pod que falhou\n- Entender por que passou no staging e falhou em prod\n- Melhorar testes/pipeline",
        "code": "# Kubernetes: rollback automÃ¡tico\nlivenessProbe:\n  httpGet:\n    path: /actuator/health/liveness\n    port: 8080\n  initialDelaySeconds: 30\n  failureThreshold: 3  # ApÃ³s 3 falhas, reinicia",
        "answer": "Primeiro, faÃ§o rollback para versÃ£o estÃ¡vel - produÃ§Ã£o tem que funcionar. Depois investigo por que falhou. Geralmente Ã© diferenÃ§a de ambiente (variÃ¡veis, secrets) ou carga de produÃ§Ã£o que nÃ£o simulamos. Por isso uso Canary release: deploy para 1% dos usuÃ¡rios primeiro, monitoro, depois expando."
      },
      {
        "id": "q-14-6",
        "title": "O que fazer quando recebe alerta de muitos erros 500?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1: Verificar (1-2 min)**\n- Dashboards (Grafana, Datadog)\n- Qual endpoint? Qual serviÃ§o?\n- ComeÃ§ou quando?\n**Passo 2: Correlacionar**\n- Houve deploy recente?\n- DependÃªncia externa caiu?\n- Pico de trÃ¡fego?\n**Passo 3: Logs**\n**Passo 4: AÃ§Ã£o baseada na causa**",
        "code": "# Buscar erros recentes\nkubectl logs <pod> --since=5m | grep ERROR",
        "table": {
          "headers": [
            "Causa",
            "AÃ§Ã£o"
          ],
          "rows": [
            [
              "Deploy quebrou",
              "Rollback"
            ],
            [
              "DependÃªncia fora",
              "Circuit breaker, fallback"
            ],
            [
              "Pico de trÃ¡fego",
              "Escalar pods"
            ],
            [
              "Bug de cÃ³digo",
              "Hotfix"
            ],
            [
              "Banco lento",
              "Matar queries, otimizar"
            ]
          ]
        },
        "answer": "Verifico imediatamente no Grafana qual endpoint e desde quando. Correlaciono com deploys ou mudanÃ§as. Se foi deploy, rollback. Se foi dependÃªncia, ativo fallback. Enquanto investigo, comunico o time. Depois de resolver, documento o que aconteceu."
      }
    ]
  },
  {
    "id": "section-15",
    "title": "ğŸ”¥ 15. TÃ“PICOS AVANÃ‡ADOS (NÃVEL SÃŠNIOR)",
    "questions": [
      {
        "id": "q-15-0",
        "title": "O que sÃ£o Virtual Threads (Java 21) e por que sÃ£o importantes?",
        "tags": [
          "avanÃ§ado"
        ],
        "content": "Virtual Threads (Project Loom) sÃ£o threads leves gerenciadas pela JVM, nÃ£o pelo Sistema Operacional.\n**Quando usar:**\nOperaÃ§Ãµes I/O-bound (HTTP calls, banco de dados, arquivos). NÃ£o para CPU-bound.\n**Exemplo prÃ¡tico:**\n**No ConsignadoHub:**\n*\"Seria perfeito para o serviÃ§o que consulta a API do INSS. A thread fica parada esperando resposta HTTP. Com Virtual Threads, poderÃ­amos escalar para milhares de requisiÃ§Ãµes concorrentes sem estourar memÃ³ria.\"*",
        "table": {
          "headers": [
            "Aspecto",
            "Thread de Plataforma",
            "Virtual Thread"
          ],
          "rows": [
            [
              "Gerenciamento",
              "Sistema Operacional",
              "JVM"
            ],
            [
              "MemÃ³ria",
              "~1 MB por thread",
              "Poucos KB"
            ],
            [
              "Quantidade",
              "Milhares = problema",
              "MilhÃµes = OK"
            ],
            [
              "CriaÃ§Ã£o",
              "Custosa",
              "Barata"
            ]
          ]
        },
        "code": "// Antes: Thread pool limitado\nExecutorService executor = Executors.newFixedThreadPool(100);\n\n// Depois: Virtual threads ilimitadas\nExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-15-1",
        "title": "Qual a diferenÃ§a entre Optimistic e Pessimistic Locking?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "**Optimistic Locking com JPA:**\n**Pessimistic Locking:**\n**No ConsignadoHub:**\n*\"Para reserva de margem consignÃ¡vel, usaria Optimistic Locking com @Version. Se dois atendentes tentarem vender emprÃ©stimo na mesma margem ao mesmo tempo, um deles recebe erro e deve tentar novamente. Evita travar o banco desnecessariamente.\"*",
        "table": {
          "headers": [
            "Aspecto",
            "Optimistic (Otimista)",
            "Pessimistic (Pessimista)"
          ],
          "rows": [
            [
              "Quando trava",
              "No commit",
              "Na leitura"
            ],
            [
              "ImplementaÃ§Ã£o",
              "`@Version` no JPA",
              "`SELECT FOR UPDATE`"
            ],
            [
              "Performance",
              "Melhor (nÃ£o trava banco)",
              "Pior (trava registro)"
            ],
            [
              "Conflitos",
              "Detecta no final",
              "Previne desde o inÃ­cio"
            ],
            [
              "Uso ideal",
              "Pouca concorrÃªncia",
              "Muita concorrÃªncia"
            ]
          ]
        },
        "code": "@Query(\"SELECT c FROM Conta c WHERE c.id = :id\")\n@Lock(LockModeType.PESSIMISTIC_WRITE)\nOptional<Conta> findByIdForUpdate(@Param(\"id\") Long id);",
        "tip": "No ConsignadoHub:"
      },
      {
        "id": "q-15-2",
        "title": "Quais sÃ£o os 3 Pilares da Observabilidade?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Logs:**\nEventos textuais. \"Cliente X cadastrado Ã s 10:30\".\n**MÃ©tricas:**\nNÃºmeros agregados. \"500 erros/minuto\", \"p99 latÃªncia = 200ms\".\n**Tracing DistribuÃ­do:**\nRastreia uma requisiÃ§Ã£o atravÃ©s de mÃºltiplos serviÃ§os.\n**Resposta resumida:**\n*\"Os trÃªs pilares sÃ£o Logs, MÃ©tricas e Tracing. Logs mostram o que aconteceu, mÃ©tricas mostram tendÃªncias numÃ©ricas, e tracing distribuÃ­do mostra onde estÃ¡ a lentidÃ£o em arquiteturas de microserviÃ§os. No Spring Boot, uso Micrometer para exportar mÃ©tricas para Prometheus.\"*",
        "table": {
          "headers": [
            "Pilar",
            "O que responde",
            "Ferramentas"
          ],
          "rows": [
            [
              "**Logs**",
              "O que aconteceu?",
              "ELK Stack, Splunk, CloudWatch"
            ],
            [
              "**MÃ©tricas**",
              "Quanto? TendÃªncia?",
              "Prometheus + Grafana, Micrometer"
            ],
            [
              "**Tracing**",
              "Onde estÃ¡ a lentidÃ£o?",
              "Jaeger, Zipkin, OpenTelemetry"
            ]
          ]
        },
        "code": "Request ID: abc-123\nâ”œâ”€â”€ Gateway (5ms)\nâ”œâ”€â”€ CustomerService (50ms)\nâ”‚   â””â”€â”€ PostgreSQL (45ms)  â† Gargalo identificado!\nâ””â”€â”€ SimulationService (10ms)"
      },
      {
        "id": "q-15-3",
        "title": "Como funciona autenticaÃ§Ã£o com JWT/OAuth2?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Fluxo simplificado:**\n**JWT (JSON Web Token):**\n**Spring Security com JWT:**\n**Resposta resumida:**\n*\"O frontend autentica no Identity Provider (Keycloak, Auth0) e recebe um JWT. A cada request, envia o token no header Authorization: Bearer <token>. O backend apenas valida a assinatura do JWT - Ã© stateless, nÃ£o precisa de sessÃ£o no servidor.\"*",
        "code": "@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        return http\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt())\n            .build();\n    }\n}"
      },
      {
        "id": "q-15-4",
        "title": "Como vocÃª otimiza um Dockerfile para Java?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Multi-stage build:**\n**OtimizaÃ§Ãµes:**\n1. **Multi-stage:** Imagem final nÃ£o tem JDK/Maven\n2. **Imagem Alpine:** Muito menor que Ubuntu\n3. **Cache de layers:** `COPY pom.xml` antes do `COPY src`\n4. **JRE, nÃ£o JDK:** Runtime nÃ£o precisa compilador\n**Resultado:** Imagem de ~400MB â†’ ~150MB",
        "code": "# Stage 1: Build (imagem grande com JDK + Maven)\nFROM maven:3.9-eclipse-temurin-21 AS build\nWORKDIR /app\nCOPY pom.xml .\nRUN mvn dependency:go-offline   # Cache de dependÃªncias\nCOPY src ./src\nRUN mvn package -DskipTests\n\n# Stage 2: Runtime (imagem pequena sÃ³ com JRE)\nFROM eclipse-temurin:21-jre-alpine\nCOPY --from=build /app/target/*.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]"
      },
      {
        "id": "q-15-5",
        "title": "DiferenÃ§a entre Pod, Deployment e Service no Kubernetes?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "No Kubernetes, Pod, Deployment e Service sÃ£o recursos fundamentais que trabalham juntos:\n\n**Pod:** Ã‰ a menor unidade executÃ¡vel. ContÃ©m um ou mais containers rodando juntos. Pods sÃ£o efÃªmeros - podem morrer e ser recriados.\n\n**Deployment:** Gerencia Pods de forma declarativa. VocÃª diz \"quero 3 rÃ©plicas\" e o Kubernetes garante que sempre haverÃ¡ 3 Pods rodando. Cuida de rolling updates e rollbacks.\n\n**Service:** Fornece um endpoint estÃ¡vel (DNS) para acessar Pods. Como Pods tÃªm IPs dinÃ¢micos, o Service funciona como load balancer e proxy.",
        "table": {
          "headers": [
            "Conceito",
            "O que Ã©",
            "Analogia"
          ],
          "rows": [
            [
              "**Pod**",
              "Menor unidade, contÃ©m 1+ containers",
              "Uma instÃ¢ncia da aplicaÃ§Ã£o"
            ],
            [
              "**Deployment**",
              "Gerencia rÃ©plicas de Pods",
              "\"Quero 3 cÃ³pias rodando\""
            ],
            [
              "**Service**",
              "ExposiÃ§Ã£o de rede, load balancer",
              "DNS fixo para acessar os Pods"
            ]
          ]
        },
        "code": "# Deployment: 3 rÃ©plicas do meu app\napiVersion: apps/v1\nkind: Deployment\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: customer-service\n        image: consignado/customer:1.0.0\n\n---\n# Service: ExpÃµe na porta 80, roteia para Pods\napiVersion: v1\nkind: Service\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    targetPort: 8080"
      },
      {
        "id": "q-15-6",
        "title": "DiferenÃ§a entre Optional.of e Optional.ofNullable?",
        "tags": [
          "bÃ¡sico"
        ],
        "content": "**Resposta (pegadinha clÃ¡ssica):**\n**Quando usar cada:**",
        "table": {
          "headers": [
            "MÃ©todo",
            "Se valor for null",
            "Quando usar"
          ],
          "rows": [
            [
              "`Optional.of(valor)`",
              "**LanÃ§a NullPointerException**",
              "Quando null Ã© erro de programaÃ§Ã£o"
            ],
            [
              "`Optional.ofNullable(valor)`",
              "Retorna `Optional.empty()`",
              "Quando ausÃªncia Ã© esperada"
            ]
          ]
        },
        "code": "// of() - tenho certeza que nÃ£o Ã© nulo\nOptional<Cliente> cliente = Optional.of(clienteRepository.findById(id).orElseThrow());\n\n// ofNullable() - pode ser nulo\nOptional<String> email = Optional.ofNullable(cliente.getEmail());"
      },
      {
        "id": "q-15-7",
        "title": "Como identificar problemas de performance no banco? (EXPLAIN ANALYZE)",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "Quando endpoint estÃ¡ lento, rodo `EXPLAIN ANALYZE` na query:\n**Resultado ruim (Full Table Scan):**\n**Resultado bom (Index Scan):**\n**Regra:** Se vejo \"Seq Scan\" em tabela grande, falta Ã­ndice. Adiciono via Flyway:",
        "code": "CREATE INDEX idx_clientes_cpf ON clientes(cpf);"
      },
      {
        "id": "q-15-8",
        "title": "O que fazer quando hÃ¡ dados inconsistentes no banco?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1:** Identificar escopo - quantos registros? Quando comeÃ§ou?\n**Passo 2:** Parar a causa - hotfix/rollback\n**Passo 3:** CorreÃ§Ã£o\n**Passo 4:** Prevenir - adicionar constraint, validaÃ§Ã£o",
        "code": "-- Encontrar registros problemÃ¡ticos\nSELECT * FROM contratos WHERE valor_liberado > margem_disponivel;",
        "answer": "Primeiro paro a causa (hotfix). Quantifico com queries. Corrijo com script SQL. Documento e adiciono validaÃ§Ã£o para nÃ£o acontecer de novo."
      },
      {
        "id": "q-15-9",
        "title": "O que fazer quando transaÃ§Ã£o trava (deadlock)?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**O que Ã©:** Duas transaÃ§Ãµes esperando lock uma da outra.\n**Resolver imediato:**\n**Prevenir:** Sempre lockar na mesma ordem",
        "code": "Long first = Math.min(contaOrigemId, contaDestinoId);\nLong second = Math.max(contaOrigemId, contaDestinoId);\n// Locka sempre na ordem first â†’ second",
        "answer": "Deadlock Ã© quando duas transaÃ§Ãµes ficam esperando lock uma da outra. Previno garantindo que todos lockam na mesma ordem - sempre pelo menor ID primeiro."
      },
      {
        "id": "q-15-10",
        "title": "O que fazer quando hÃ¡ duplicaÃ§Ã£o de dados?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Causas:** Falta de UNIQUE constraint, retry sem idempotÃªncia, race condition.\n**Corrigir:**\n**IdempotÃªncia:**",
        "code": "if (repository.existsByIdempotencyKey(evento.key())) {\n    return; // JÃ¡ processado\n}",
        "answer": "DuplicaÃ§Ã£o Ã© falta de constraint UNIQUE ou falta de idempotÃªncia. Corrijo dados, adiciono constraint, implemento idempotÃªncia com chave Ãºnica."
      },
      {
        "id": "q-15-11",
        "title": "O que fazer quando logs estÃ£o confusos/difÃ­cil de rastrear?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Problema:** Muitos logs sem contexto de qual request.\n**SoluÃ§Ã£o: Correlation ID via MDC**\n**Resultado:**",
        "code": "10:00:01 [abc-123] INFO Processando cliente\n10:00:01 [abc-123] ERROR Falhou\nâ†’ grep \"abc-123\" para ver toda a jornada",
        "answer": "Uso Correlation ID via MDC. Cada request tem UUID Ãºnico em todos os logs. FÃ¡cil filtrar e rastrear."
      },
      {
        "id": "q-15-12",
        "title": "O que fazer quando nÃ£o consegue reproduzir um bug?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "1. **Coletar:** logs, request exato, timestamp, versÃ£o\n2. **Reproduzir:** com mesmos dados em ambiente local\n3. **DiferenÃ§as:** verificar configs, dados, timing\n4. **Se nÃ£o reproduzir:** adicionar logs extras, monitorar prÃ³xima ocorrÃªncia",
        "answer": "Coleto todos os dados disponÃ­veis. Tento reproduzir localmente. Se nÃ£o conseguir, adiciono logs extras e monitoro para capturar mais informaÃ§Ãµes na prÃ³xima ocorrÃªncia."
      },
      {
        "id": "q-15-13",
        "title": "O que fazer quando cliente reclama de lentidÃ£o?",
        "tags": [
          "intermediÃ¡rio"
        ],
        "content": "**Passo 1:** Qual endpoint? Desde quando? SÃ³ ele ou todos?\n**Passo 2:** Usar APM/tracing para ver gargalo\n**Passo 3:** Resolver por causa\n- Banco lento â†’ Ã­ndice\n- API externa â†’ cache, async\n- Muitos dados â†’ paginaÃ§Ã£o",
        "code": "Request (500ms total)\nâ”œâ”€â”€ Controller (5ms)\nâ”œâ”€â”€ Service (20ms)  \nâ”œâ”€â”€ Database (450ms)  â† GARGALO\nâ””â”€â”€ Response (5ms)",
        "answer": "Uso APM para ver qual camada estÃ¡ lenta. Geralmente Ã© banco sem Ã­ndice ou API externa. Resolvo a causa e valido com cliente."
      }
    ]
  }
]